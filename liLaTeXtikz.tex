% Questo è il pacchetto liLaTeX per tikz

\usepackage{tkz-euclide} % per alcune funzioni grafiche (come \intrette)
\usepackage{pgfplots} % pacchetto per plot
\pgfplotsset{compat=1.17} % necessario per compatibilità con versioni precedenti

%%%%%%%%%%%%%%%%	AMBIENTE immagine

% le immagini vengono generalmente create fra \begin{immagine}[opzioni] e \end{immagine}
\newenvironment*{immagine}[1][]
	{\ifdefstring{\TipoDoc}{immagine}{}{\begin{figure}[!ht]\centering}\begin{tikzpicture}[#1]}
	{\end{tikzpicture}\ifdefstring{\TipoDoc}{immagine}{}{\end{figure}}}

% analogo ad immagine, ma permette di aggiungere una caption
% chiama come \begin{immaginecap}[opzioni]{caption} ... \end{immaginecap}
\newenvironment*{immaginecap}[2][]
	{\def\immaginecapCaption{#2}\begin{figure}[!ht]\centering\begin{tikzpicture}[#1]}
	{\end{tikzpicture}\caption{\immaginecapCaption}\end{figure}}
\newenvironment*{immaginecap*}[2][]
	{\def\immaginecapCaption{#2}\begin{figure}[!ht]\centering\begin{tikzpicture}[#1]}
	{\end{tikzpicture}\caption*{\immaginecapCaption}\end{figure}}
	
% \begin{rotazione}[centro rotazione]{ang}picture\end{rotazione} disegna l'immagine ruotata
% Attenzione! una coordinata fornita come (1,2) verrà ruotata, ma una coordinata data come P non verrà ruotata. È un comportamento un po' anomalo, ma il rotate around di tikz funziona in questo modo
\newenvironment*{rotazione}[2][0,0]
	{\begin{scope}[rotate around={#2:(#1)}]}
	{\end{scope}}


%%%%%%%%%%%%%%%%	KEY MANAGER

% da chiamare all'inizio di qualunque comando con dei parametri opzionali come \setkeyfld{parametri opzionali}. Dovrebbe essere sempre la seconda riga di qualunque newcommand con parametri opzionali
\newcommand*{\setkeyfld}[1]{
	% passiamo alla key directory keyfld, e ridefiniamo come #1 tutti le keys specificate in #1
	\tikzset{keyfld/.cd,#1}%
	% definiamo un soprannome \kv per il path alle keys. In questo modo, per riferirci al VALORE di una chiave chiamata K dovremo scrivere \kv{K}, anziché la più lunga /tikz/keyfld/K. Quindi K indica la chiave, mentre \kv{K} indica il suo valore
	\def\kp##1{/tikz/keyfld/##1}
	\def\kv##1{\pgfkeysvalueof{/tikz/keyfld/##1}}
}

% \ifkeyequal{keyname}{value to compare}{do if equal}{do if different}
\newcommand*{\ifkeyequal}[4]{
	\edef\ifkeyequalkey{\kv{#1}} 
	\edef\ifkeyequalcomp{#2}
	\ifdefequal{\ifkeyequalkey}{\ifkeyequalcomp}{#3}{#4}
}

% \ifkeyempty{keyname}{do if empty}{do if non-empty}. Non funziona se keyname è un label (potrebbe contenere cose come \mathrm, che non sono compatibili
\newcommand*{\ifkeyempty}[3]{\ifkeyequal{#1}{\pgfkeysnovalue}{#2}{#3}}

% aggiorna il valore della key #1 al valore #2. Chiama ad esempio come \setkeyvalue{color}{blue} o come \setkeyvalue{h}{\kv{b}}
\newcommand*{\setkeyvalue}[2]{\pgfkeyssetvalue{\kp{#1}}{#2}}
% copia il valore della key #2 nella key #1
\newcommand*{\copykeyvalue}[2]{\setkeyvalue{#1}{\kv{#2}}}
% aggiorna il valore della key #1 al valore #2 solo se #1 è empty
\newcommand*{\setkeyvalueifempty}[2]{\ifkeyempty{#1}{\setkeyvalue{#1}{#2}}{}}
% aggiorna il valore della key #1 al valore \kv{#2} solo se #1 è empty
\newcommand*{\copykeyvalueifempty}[2]{\setkeyvalueifempty{#1}{\kv{#2}}}

% aggiorna i valori di diverse keys se sono vuoti. Analoghi a chiamare \setkeyvalueifempty o \copykeyvalueifempty diverse volte di fila
\makeatletter
\newcommand*{\setkeyvaluesifempty}[2]{\setkeyvalueifempty{#1}{#2}\@ifnextchar\bgroup{\setkeyvaluesifempty}{}}
\newcommand*{\copykeyvaluesifempty}[2]{\copykeyvalueifempty{#1}{#2}\@ifnextchar\bgroup{\copykeyvaluesifempty}{}}
\makeatother


%%%%%%%%%%%%%%%%	FUNZIONI

% definisce un valore numerico #1 uguale all'output dell'operazione #2
\newcommand*\tikzdef[2]{\pgfmathsetmacro{#1}{#2}} % definisce float #1:=#2

% converte da pt a cm. Chiama come \convertto{cm}{misura pt}
\makeatletter
\def\convertto#1#2{\strip@pt\dimexpr #2*65536/\number\dimexpr 1#1}
\makeatother

% restituisce in output il nome del comando in input
\newcommand*{\commandname}[1]{\expandafter{\string#1}}

% restituisce il nome del comando #1 senzo lo slash
\newcommand*{\commandstring}[1]{\removeslash{#1}}

% rimuove lo \ dall'input
\newcommand*{\removeslash}[1]{{\catcode92=9 \endlinechar-1 \scantokens{#1}}}

% registra la distanza fra #2 e #3 in #1
\newcommand*{\distanza}[3]{
	\coordinate(distanzafrom)at(#2);
	\coordinate(distanzato)at(#3);
	\tkzCalcLength(distanzafrom,distanzato)
		\tkzGetLength{distanzaTemp}
	\def\distanzaTempincm{\convertto{cm}{\distanzaTemp pt}};
	\tikzdef#1{\distanzaTempincm};
}

% angolopolare{<- \a}{P}{O} registra in \a la coordinata angolare di P in un sistema di rif. centrato in O
\newcommand*{\angolopolare}[3]{
	\coordinate(angolopolareterzopunto)at($(#3)+(1,0)$);
	\coordinate(angolopolareP)at(#2);
	\coordinate(angolopolareO)at(#3);
	\tkzFindAngle(angolopolareterzopunto,angolopolareO,angolopolareP)
		\tkzGetAngle{angolopolareoutput}
		\def#1{\angolopolareoutput};
}


%%%%%%%%%%%%%%%% LABEL

% \stylelbl[keys]{coord} scrive il label nel formato specificato
\newcommand*{\stylelbl}[2][]{
	\tikzset{keyfld/.cd,
		lbl/.initial,
		lbl size/.initial,
		lbl name/.initial = scriptlblName,
		col/.initial,
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\PRIVstylelbl[
		PRIVlbl lbl=\kv{lbl},
		PRIVlbl lbl size=\kv{lbl size},
		PRIVlbl lbl name=\kv{lbl name},
		PRIVlbl col=\kv{col},
		PRIVlbl lbl col=\kv{lbl col},
		PRIVlbl col lbl=\kv{col lbl},
	]{#2};
}

% \PRIVstylelbl[keys]{coord} analogo a \stylelbl, ma da usare nelle funzioni di questo pacchetto
\newcommand*{\PRIVstylelbl}[2][]{
	\tikzset{keyfld/.cd,
		PRIVlbl lbl/.initial,
		PRIVlbl lbl size/.initial,
		PRIVlbl lbl name/.initial = scriptlblName,
		PRIVlbl col/.initial,
		PRIVlbl lbl col/.initial,
		PRIVlbl col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\copykeyvaluesifempty
		{PRIVlbl lbl col}{PRIVlbl col}
		{PRIVlbl col lbl}{PRIVlbl lbl col}
	\node[\kv{PRIVlbl col lbl}] (\kv{PRIVlbl lbl name}) at (#2) {\kv{PRIVlbl lbl size}\kv{PRIVlbl lbl}};
}

%%%%%%%%%%%%%%%%	PUNTO
% Attenzione! coordinate create come \punto (o suoi derivati) sono incompatibili con l'opzione fill per eventuali poligoni. Questo vuol dire che se vogliamo disegnare un poligono colorato, dobbiamo definire i punti come \coordinate, poi usare fill, e infine ripassare i vertici con \punto

% chiama come \punto[keys]{coordinate}
\newcommand*{\punto}[2][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		size/.initial = 1.5,
		shape/.initial = circle, % circle, rettangle o lo si può lasciare vuoto
		name/.initial = puntoNome,
		lbl/.initial,
		lbl name/.initial,
		lbl ang/.initial = -90,
		lbl dist/.initial = 0.3,
		lbl size/.initial,
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\coordinate[\kv{shape},inner sep=\kv{size},fill=\kv{col}] (\kv{name}) at (#2);
	\PRIVstylelbl[
		PRIVlbl lbl=\kv{lbl},
		PRIVlbl lbl size=\kv{lbl size},
		PRIVlbl lbl name=\kv{lbl name},
		PRIVlbl col=\kv{col},
		PRIVlbl lbl col=\kv{lbl col},
		PRIVlbl col lbl=\kv{col lbl},
	]{$(#2)+(\kv{lbl ang}:\kv{lbl dist})$};
}

% chiama come \pnt[col]{nome}{coordinate}
\newcommand*{\pnt}[3][]{\punto[name=#2,col=#1]{#3};}
% chiama come \pntlbl[col]{nome}{lbl}{lbl ang}{coordinate}
\newcommand*{\pntlbl}[5][]{\punto[name=#2,lbl=#3,lbl ang=#4,col=#1]{#5};}
% chiama come \pntl[col]{name}{lbl ang}{coordinate}
\newcommand*{\pntl}[4][]{\pntlbl[#1]{#2}{$#2$}{#3}{#4};}
% chiama come \pntlp[col]{name}{lbl ang}{coordinate}
\newcommand*{\pntlp}[4][]{\pntlbl[#1]{#2p}{$#2'$}{#3}{#4};}
% chiama come \pntls[col]{name}{lbl ang}{coordinate}
\newcommand*{\pntls}[4][]{\pntlbl[#1]{#2s}{$#2''$}{#3}{#4};}


%%%%%%%%%%%%%%%%	CALCOLO DI COORDINATE

% \verso[L]{<- P}{A}{B} crea un punto P ottenuto traslando A verso B per una lunghezza complessiva L
\newcommand*{\verso}[4][1]{\coordinate (#2) at ($(#3)!#1cm!(#4)$);}
% \allont[L]{<- P}{A}{B} analogo di \verso ma allontanandosi da B
\newcommand*{\allont}[4][1]{\verso[-#1]{#2}{#3}{#4};}

% \parallelo[L]{<- P}{S}{A}{B} crea un punto P, ottenuto traslando S per una lunghezza L nel verso nel vettore AB
\newcommand*{\parallelo}[5][1]{\coordinate (#2) at ($(#3)-(#4)+(#4)!#1cm!(#5)$);}

% \perpendicolare[L]{<- P}{S}{A}{B} crea un punto P, ottenuto traslando S per una lunghezza L nel verso perpendicolare a AB (si suppone SAB in senso antiorario)
\newcommand*{\perpendicolare}[5][1]{\coordinate (#2) at ($(#3)-(#4)+(#4)!#1cm!-90:(#5)$);}

% \medio[k]{<- M}{A}{B} definisce M come il punto (1-k)*A+k*B. Nel caso speciale di k=0.5, M è il punto medio del segmento AB. Quindi se k=0 risulta M:=A, mentre se k=1 risulta M:=B
\newcommand*{\medio}[4][0.5]{\coordinate(#2)at($(#3)-#1*(#3)+#1*(#4)$);}

% \opposto{<- P'}{P}{O} crea l'opposto P' di P rispetto al centro di simmetria O
\newcommand*{\opposto}[3]{\coordinate(#1)at($2*(#3)-(#2)$);}

% \simmetrico{<- P'}{P}{A}{B} crea il punto P', simmetrico di P rispetto alla retta di simmetria AB
\newcommand*{\simmetrico}[4]{
	\proj{simmetricoPuntoDiProiezione}{#2}{#3}{#4};
	\opposto{#1}{#2}{simmetricoPuntoDiProiezione};
}

% \proj{<- H}{P}{A}{B} genera H come la proiezione ortogonale di P sulla retta AB
\newcommand*{\proj}[4]{
	\coordinate(projPcoordinate)at(#2);
	\coordinate(projAcoordinate)at(#3);
	\coordinate(projBcoordinate)at(#4);
	\tkzDefPointBy[projection=onto projAcoordinate--projBcoordinate](projPcoordinate)
		\tkzGetPoint{#1};
}

% \sumvett{<- C}{A}{B}{D} definisce il punto C in modo che il vettore AC sia uguale alla somma vettoriale AB+AD. Così facendo ABCD forma un parallelogramma
\newcommand*{\sumvett}[4]{\coordinate(#1)at($(#3)-(#2)+(#4)$);}

% \ruotapunto{<- R}{P}{O}{a} definisce il punto R ottenuto ruotando P in senso antiorario di un angolo a (con centro di rotazione in O)
\newcommand*{\ruotapunto}[4]{
	\coordinate(ruotapuntoP)at(#2);
	\coordinate(ruotapuntoO)at(#3);
	\tkzDefPointBy[rotation= center ruotapuntoO angle #4](ruotapuntoP)
		\tkzGetPoint{#1};
}

% \ruotapuntoN[L]{<- R}{P}{O}{a} dopo aver ruotato il punto, lo normalizza per farlo diventare di luunghezza L
\newcommand*{\ruotapuntoN}[5][1]{
	\ruotapunto{ruotapuntoNnonnormalizzato}{#3}{#4}{#5};
	\verso[#1]{#2}{#4}{ruotapuntoNnonnormalizzato};
}

% \triangoloequilatero{<- C}{A}{B} prende in input due punti A e B, e definisce un terzo punto C in modo che ABC sia un triangolo equilatero (coi vertici scritti in senso antiorario)
\newcommand*{\triangoloequilatero}[3]{
	\coordinate(triangoloequilateroA)at(#2);
	\coordinate(triangoloequilateroB)at(#3);
	\tkzDefTriangle[equilateral](triangoloequilateroA,triangoloequilateroB)
		\tkzGetPoint{#1}
}


%%%%%%%%%%%%%%%%	INTERSEZIONI

% \intpahts{<- I}{path1}{path2} trova il punto di intersezione fra due paths e lo chiama I
\newcommand*{\intpaths}[3]{\path [name intersections={of=#2 and #3, by=#1}];}

% \intrette{<- I}{A}{B}{C}{D} trova il punto di intersezione I fra le rette AB e CD
\newcommand*{\intrette}[5]{
	\coordinate(intretteA)at(#2);
	\coordinate(intretteB)at(#3);
	\coordinate(intretteC)at(#4);
	\coordinate(intretteD)at(#5);
	\tkzInterLL(intretteA,intretteB)(intretteC,intretteD)
		\tkzGetPoint{#1};
}


%%%%%%%%%%%%%%%%	GRIGLIE SISTEMI DI RIFERIMENTO

% \griglia[keys]{west}{east}{south}{north}
\newcommand*{\griglia}[5][]{
	\tikzset{keyfld/.cd,
		col/.initial = gray!50,
		width/.initial = thin, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		step/.initial = 1, % la distanza fra due barre
		s/.initial, % equivalente a step
		step x/.initial, % se specificato indica la distanza fra due barre lungo l'asse x
		step y/.initial, % se specificato indica la distanza fra due barre lungo l'asse y
		s x/.initial, % analogo di step x
		s y/.initial, % analogo di step y
		col fill/.initial, % se specificato l'interno della griglia viene colorato
	} \setkeyfld{#1};
	\copykeyvaluesifempty
		{s}{step}
		{step x}{s}
		{step y}{s}
		{s x}{step x}
		{s y}{step y}
	\ifkeyempty{col fill}{}{\fill[\kv{col fill}] (#2,#4)rectangle(#3,#5);}
	\draw[\kv{col},\kv{width},\kv{pattern}] (#2,#4) grid [xstep=\kv{s x} cm,ystep=\kv{s y} cm] (#3,#5);
}
% \grigliaO[keys]{east}{north}. Ha le stesse keys di \griglia
\newcommand*{\grigliaO}[3][]{\griglia[#1]{0}{#2}{0}{#3}}

% \cartamillimetrata[keys]{west}{east}{south}{north} % una porzione di carta millimetrata
\newcommand*{\cartamillimetrata}[5][]{
	\tikzset{keyfld/.cd,
		col1/.initial = pink!50,
		col2/.initial = gray!70,
		width1/.initial = ultra thin, % può essere thin, thick, ...
		width2/.initial = thin, % può essere thin, thick, ...
		pattern1/.initial, % può essere solid, dashed, dotted, ...
		pattern2/.initial, % può essere solid, dashed, dotted, ...
		step1/.initial = 0.1, % la distanza fra due barre minori (normalmente 0.1)
		step2/.initial = 0.5, % la distanza fra due barre maggiori (normalmente 0.5)
		s1/.initial, % sinonimo di step1
		s2/.initial, % sinonimo di step2
	} \setkeyfld{#1};
	\copykeyvaluesifempty
		{s1}{step1}
		{s2}{step2}
	\draw[\kv{col1},\kv{width1},\kv{pattern1}] (#2,#4) grid [step=\kv{s1}] (#3,#5);
	\draw[\kv{col2},\kv{width2},\kv{pattern2}] (#2,#4) grid [step=\kv{s2}] (#3,#5);
}

% può solo essere usata con \TipoDoc = immagine. Crea una pagina intera di carta millimetrata
\newcommand*{\cartamillimetratapagina}[1][]{\cartamillimetrata[#1]{0}{21}{0.3}{30};}

% \assex[keys]{x-left}{x-right} crea l'asse x
\newcommand*{\assex}[3][]{
	\tikzset{keyfld/.cd,
		y/.initial = 0, % la y del centro
		ang shift/.initial = 0,
		col/.initial,
		arrow/.initial = ->,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		lbl/.initial = $x$,
		lbl name/.initial = assexlbl, % il nome da dare al label
		lbl size/.initial,
		lbl dist/.initial = 0.3,
		lbl col/.initial,
		col lbl/.initial, % analogo a lbl col
		mirror lbl/.initial = false, mirror lbl/.default = true, % rendi true se vuoi ribaltare il label
	} \setkeyfld{#1};
	\ifkeyequal{mirror lbl}{true}{\def\assexmirrorper{180}}{\def\assexmirrorper{0}};
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] ($(0,\kv{y})+(\kv{ang shift}:#2)$) -- ($(0,\kv{y})+(\kv{ang shift}:#3)$)node(assexpunta){};
	\PRIVstylelbl[
		PRIVlbl lbl=\kv{lbl},
		PRIVlbl lbl size=\kv{lbl size},
		PRIVlbl lbl name=\kv{lbl name},
		PRIVlbl col=\kv{col},
		PRIVlbl lbl col=\kv{lbl col},
		PRIVlbl col lbl=\kv{col lbl},
	]{$(assexpunta)+(\kv{ang shift}-90+\assexmirrorper:\kv{lbl dist})$};
}

% \assey[keys]{y-bottom}{y-top} crea l'assey
\newcommand*{\assey}[3][]{
	\tikzset{keyfld/.cd,
		x/.initial = 0, % la x del centro
		ang shift/.initial = 0,
		col/.initial,
		arrow/.initial = ->,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		lbl/.initial = $y$,
		lbl size/.initial,
		lbl name/.initial = asseylbl, % il nome da dare al label
		lbl dist/.initial = 0.3,
		lbl col/.initial,
		col lbl/.initial, % analogo a lbl col
		mirror lbl/.initial = false, mirror lbl/.default = true, % rendi true se vuoi ribaltare il label
	} \setkeyfld{#1};
	\ifkeyequal{mirror lbl}{true}{\def\asseymirrorper{180}}{\def\asseymirrorper{0}};
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] ($(\kv{x},0)+(\kv{ang shift}+90:#2)$) -- ($(\kv{x},0)+(\kv{ang shift}+90:#3)$)node(asseypunta){};
	\PRIVstylelbl[
		PRIVlbl lbl=\kv{lbl},
		PRIVlbl lbl size=\kv{lbl size},
		PRIVlbl lbl name=\kv{lbl name},
		PRIVlbl col=\kv{col},
		PRIVlbl lbl col=\kv{lbl col},
		PRIVlbl col lbl=\kv{col lbl},
	]{$(asseypunta)+(\kv{ang shift}+180+\asseymirrorper:\kv{lbl dist})$};
}

% \assixy[keys]{x-left}{x-right}{y-left}{y-right} disegna gli assi cartesiani
\newcommand*{\assixy}[5][]{
	\tikzset{keyfld/.cd,
		x/.initial = 0, % la x del centro
		y/.initial = 0, % la y del centro
		col/.initial,
		arrow/.initial = ->,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		lbl x/.initial = $x$,
		lbl y/.initial = $y$,
		lbl x name/.initial = assixylblx, % il nome da dare al label per y
		lbl y name/.initial = assixylbly, % il nome da dare al label per y
		lbl dist/.initial = 0.3,
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col
	} \setkeyfld{#1};
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] (#2,\kv{y})--(#3,\kv{y})node(assixypuntax){};
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] (\kv{x},#4)--(\kv{x},#5)node(assixypuntay){};
	\PRIVstylelbl[
		PRIVlbl lbl=\kv{lbl x},
		PRIVlbl lbl size=\kv{lbl size},
		PRIVlbl lbl name=\kv{lbl x name},
		PRIVlbl col=\kv{col},
		PRIVlbl lbl col=\kv{lbl col},
		PRIVlbl col lbl=\kv{col lbl},
	]{$(assixypuntax)+(-90:\kv{lbl dist})$};
	\PRIVstylelbl[
		PRIVlbl lbl=\kv{lbl y},
		PRIVlbl lbl size=\kv{lbl size},
		PRIVlbl lbl name=\kv{lbl y name},
		PRIVlbl col=\kv{col},
		PRIVlbl lbl col=\kv{lbl col},
		PRIVlbl col lbl=\kv{col lbl},
	]{$(assixypuntay)+(180:\kv{lbl dist})$};
}

% \assixyO[keys]{centro}{x-left}{x-right}{y-left}{y-right} disegna gli assi cartesiani
\newcommand*{\assixyO}[6][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		arrow/.initial = ->,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		lbl x/.initial = $x$,
		lbl y/.initial = $y$,
		lbl x name/.initial = assixylblx, % il nome da dare al label per y
		lbl y name/.initial = assixylbly, % il nome da dare al label per y
		lbl dist/.initial = 0.3,
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col
	} \setkeyfld{#1};
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] (#3,0|-#2)--(#4,0|-#2)node(assixypuntax){};
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] (0,#5-|#2)--(0,#6-|#2)node(assixypuntay){};
	\PRIVstylelbl[
		PRIVlbl lbl=\kv{lbl x},
		PRIVlbl lbl size=\kv{lbl size},
		PRIVlbl lbl name=\kv{lbl x name},
		PRIVlbl col=\kv{col},
		PRIVlbl lbl col=\kv{lbl col},
		PRIVlbl col lbl=\kv{col lbl},
	]{$(assixypuntax)+(-90:\kv{lbl dist})$};
	\PRIVstylelbl[
		PRIVlbl lbl=\kv{lbl y},
		PRIVlbl lbl size=\kv{lbl size},
		PRIVlbl lbl name=\kv{lbl y name},
		PRIVlbl col=\kv{col},
		PRIVlbl lbl col=\kv{lbl col},
		PRIVlbl col lbl=\kv{col lbl},
	]{$(assixypuntay)+(180:\kv{lbl dist})$};
}

% \assexbar[keys]{\x}{lbl} disegna una barretta verticale sull'asse x in posizione \x per segnare il label lbl
\newcommand*{\assexbar}[3][]{
	\tikzset{keyfld/.cd,
		y/.initial = 0, % la y dell'asse cartesiano
		col/.initial,
		arrow/.initial,
		width/.initial = very thin, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		length/.initial = 0.2, % la lunghezza della barretta verticale
		l/.initial, % uguale a length
		lbl col/.initial,
		col lbl/.initial, % uguagle a lbl col
		mirror/.initial = false, mirror/.default = true, % se posto a true il label viene messo verso l'alto anziché verso il basso
	} \setkeyfld{#1};
	%\ifnum\value{TipoDocVerificaCounter}=0 \setkeyvalueifempty{col}{gray} \fi % se non è una verifica la barra viene colorata di grigio
	\copykeyvaluesifempty
		{l}{length}
		{lbl col}{col}
		{col lbl}{lbl col}
	\ifkeyequal{mirror}{false}
		{\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}](#2,\kv{y}+0.5*\kv{l})--++(0,-\kv{l})node[anchor=north,\kv{col lbl}]{#3};}
		{\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}](#2,\kv{y}-0.5*\kv{l})--++(0,+\kv{l})node[anchor=south,\kv{col lbl}]{#3};}
}

% \asseybar[keys]{\y}{lbl} disegna una barretta orizzontale sull'asse y in posizione \y per segnare il label lbl
\newcommand*{\asseybar}[3][]{
	\tikzset{keyfld/.cd,
		x/.initial = 0, % la x dell'asse cartesiano
		col/.initial,
		arrow/.initial,
		width/.initial = very thin, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		length/.initial = 0.2, % la lunghezza della barretta orizzontale
		l/.initial, % uguale a length
		lbl col/.initial,
		col lbl/.initial, % uguagle a lbl col
		mirror/.initial = false, mirror/.default = true, % se posto a true il label viene messo verso l'alto anziché verso il basso
	} \setkeyfld{#1};
	%\ifnum\value{TipoDocVerificaCounter}=0 \setkeyvalueifempty{col}{gray} \fi % se non è una verifica la barra viene colorata di grigio
	\copykeyvaluesifempty
		{l}{length}
		{lbl col}{col}
		{col lbl}{lbl col}
	\ifkeyequal{mirror}{false}
		{\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}](\kv{x}+0.5*\kv{l},#2)--++(-\kv{l},0)node[anchor=east,\kv{col lbl}]{#3};}
		{\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}](\kv{x}-0.5*\kv{l},#2)--++(+\kv{l},0)node[anchor=west,\kv{col lbl}]{#3};}
}

% \sistrif[keys]{centro}{angolo} crea il sistema di riferimento, ruotato dell'angolo specificato. Si usa in cinematica/dinamica per indicare le direzioni e i versi degli assi cartesiani utilizzati
\newcommand*{\sistrif}[3][]{
	\tikzset{keyfld/.cd,
		col/.initial = magenta,
		arrow/.initial = ->,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		front/.initial = 2, % la lunghezza con cui andiamo avanti
		back/.initial = 0.3, % la lunghezza per cui andiamo indietro
		front x/.initial,
		back x/.initial,
		front y/.initial,
		back y/.initial,
		mirror/.initial = false, mirror/.default = true, % rendi true se vuoi capovolgere il verso dell'asse y
		no label/.initial = false, no label/.default = true, % rendi true se non vuoi il label
		lbl dist/.initial = 0.3,
		lbl x/.initial = $x$,
		lbl y/.initial = $y$,
		lbl col/.initial,
		col lbl/.initial, % sinonimo di col lbl
	} \setkeyfld{#1};
	\copykeyvaluesifempty
		{front x}{front}
		{front y}{front}
		{back x}{back}
		{back y}{back}
		{lbl col}{col}
		{col lbl}{lbl col}
	\ifkeyequal{mirror}{false}{\def\sistrifmirrorper{+1}}{\def\sistrifmirrorper{-1}}
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] ($(#2)+(#3:-\kv{back x})$) -- ($(#2)+(#3:\kv{front x})$)node(sistrifLblXpunta){};
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] ($(#2)+(\sistrifmirrorper*90+#3:-\kv{back y})$) -- ($(#2)+(\sistrifmirrorper*90+#3:\kv{front y})$)node(sistrifLblYpunta){};
	\ifkeyequal{no label}{true}{}{
		\PRIVstylelbl[PRIVlbl lbl=\kv{lbl x},PRIVlbl col lbl=\kv{col lbl}]{$(sistrifLblXpunta)+(#3-90*\sistrifmirrorper:\kv{lbl dist})$};
		\PRIVstylelbl[PRIVlbl lbl=\kv{lbl y},PRIVlbl col lbl=\kv{col lbl}]{$(sistrifLblYpunta)+(#3+180:\kv{lbl dist})$};
	}
}


%%%%%%%%%%%%%%%%	TRIANGOLI

% \piedemed[k]{<- P}{A}{B}{C} trova il piede P della mediana BP (k è un parametro fra 0 e 1 che "sposta" P lungo il lato AC)
\newcommand*{\piedemed}[5][0.5]{\medio[#1]{#2}{#3}{#5};}

% \piedealt{<- P}{A}{B}{C} trova P (il piede dell'altezza BP)
\newcommand*{\piedealt}[4]{\proj{#1}{#3}{#2}{#4};}

% \piedebis{<- P}{A}{B}{C} trova P (il piede della bisettrice dell'angolo ABC)
\newcommand*{\piedebis}[4]{
	\coordinate(piedebisA)at(#2);
	\coordinate(piedebisB)at(#3);
	\coordinate(piedebisC)at(#4);
	\tkzDefLine[bisector](piedebisA,piedebisB,piedebisC)
		\tkzGetPoint{piedebisTemp}
	\intrette{#1}{piedebisTemp}{#3}{#2}{#4};
}

% \centrotriangolo[type]{<- P}{A}{B}{C} trova il centro del triangolo (funzione usata per definire i successivi 5 comandi)
\newcommand*{\centrotriangolo}[5][centroid]{
	\coordinate(centrotriangoloA)at(#3);
	\coordinate(centrotriangoloB)at(#4);
	\coordinate(centrotriangoloC)at(#5);
	\tkzDefTriangleCenter[#1](centrotriangoloA,centrotriangoloB,centrotriangoloC)
		\tkzGetPoint{#2};
}
% \baricentro{<- P}{A}{B}{C} trova il baricentro P di un triangolo ABC
\newcommand*{\baricentro}[4]{\centrotriangolo[centroid]{#1}{#2}{#3}{#4}}
% \ortocentro{<- P}{A}{B}{C} trova il baricentro P di un triangolo ABC
\newcommand*{\ortocentro}[4]{\centrotriangolo[ortho]{#1}{#2}{#3}{#4}}
% \circocentro{<- P}{A}{B}{C} trova il baricentro P di un triangolo ABC
\newcommand*{\circocentro}[4]{\centrotriangolo[circum]{#1}{#2}{#3}{#4}}
% \incentro{<- P}{A}{B}{C} trova il baricentro P di un triangolo ABC
\newcommand*{\incentro}[4]{\centrotriangolo[in]{#1}{#2}{#3}{#4}}
% \exocentro{<- P}{A}{B}{C} trova il baricentro P di un triangolo ABC (opposto a B)
\newcommand*{\excentro}[4]{\centrotriangolo[ex]{#1}{#2}{#3}{#4}}

% \triangolobase[keys]{A}{B}{C} disegna un triangolo ABC, con label per vertici, angoli e lati
\newcommand*{\triangolobase}[4][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		col vertici/.initial,
		col lati/.initial,
		col angoli/.initial,
		fill angoli/.initial = false, fill angoli/.default = true,
		col fill angoli/.initial,
		opacity angoli/.initial = 30,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		no label vertici/.initial = false, no label vertici/.default = true,
		no label lati/.initial = false, no label lati/.default = true,
		no label angoli/.initial = false, no label angoli/.default = true,
		lbl vertici dist/.initial = 0.3,
	} \setkeyfld{#1};
	\copykeyvaluesifempty
		{col vertici}{col}
		{col lati}{col}
		{col angoli}{col}
	\ifkeyequal{fill angoli}{true}{
		\ifkeyempty{col angoli}
		{\setkeyvalueifempty{col fill angoli}{black!\kv{opacity angoli}}}
		{\setkeyvalueifempty{col fill angoli}{\kv{col angoli}!\kv{opacity angoli}}}
	}{}
	\ifkeyempty{col fill angoli}{}{\setkeyvalue{fill angoli}{true}}
	\ifkeyequal{no label angoli}{true}{
		\PRIVangolo[PRIV col=\kv{col angoli},PRIV fill=\kv{fill angoli},PRIV col fill=\kv{col fill angoli}]{#3}{#2}{#4};
		\PRIVangolo[PRIV col=\kv{col angoli},PRIV fill=\kv{fill angoli},PRIV col fill=\kv{col fill angoli}]{#4}{#3}{#2};
		\PRIVangolo[PRIV col=\kv{col angoli},PRIV fill=\kv{fill angoli},PRIV col fill=\kv{col fill angoli}]{#2}{#4}{#3};
	}{
		\PRIVangolo[PRIV col=\kv{col angoli},PRIV fill=\kv{fill angoli},PRIV col fill=\kv{col fill angoli},PRIV lbl=$\alpha$]{#3}{#2}{#4};
		\PRIVangolo[PRIV col=\kv{col angoli},PRIV fill=\kv{fill angoli},PRIV col fill=\kv{col fill angoli},PRIV lbl=$\beta$]{#4}{#3}{#2};
		\PRIVangolo[PRIV col=\kv{col angoli},PRIV fill=\kv{fill angoli},PRIV col fill=\kv{col fill angoli},PRIV lbl=$\gamma$]{#2}{#4}{#3};
	}
	\ifkeyequal{no label lati}{true}{
		\PRIVsegmento[PRIV col=\kv{col lati}]{#3}{#4};
		\PRIVsegmento[PRIV col=\kv{col lati}]{#4}{#2};
		\PRIVsegmento[PRIV col=\kv{col lati}]{#2}{#3};
	}{
		\PRIVsegmento[PRIV col=\kv{col lati},PRIV lbl=$\ra$]{#3}{#4};
		\PRIVsegmento[PRIV col=\kv{col lati},PRIV lbl=$\rb$]{#4}{#2};
		\PRIVsegmento[PRIV col=\kv{col lati},PRIV lbl=$\rc$]{#2}{#3};
	}
	\ifkeyequal{no label vertici}{false}{
		\baricentro{triangolobasebaricentro}{#2}{#3}{#4};
		\allont[\kv{lbl vertici dist}]{triangolobaselbllato}{#2}{triangolobasebaricentro};
		\node[\kv{col vertici}](triangolobaselbllato)at(triangolobaselbllato){$A$};
		\allont[\kv{lbl vertici dist}]{triangolobaselbllato}{#3}{triangolobasebaricentro};
		\node[\kv{col vertici}](triangolobaselbllato)at(triangolobaselbllato){$B$};
		\allont[\kv{lbl vertici dist}]{triangolobaselbllato}{#4}{triangolobasebaricentro};
		\node[\kv{col vertici}](triangolobaselbllato)at(triangolobaselbllato){$C$};
	}{}
}


%%%%%%%%%%%%%%%%	MARKS accettano le opzioni s,z,x,o,oo,|,||,|||

% chiama come \segmento[keys]{A}{B} per disegnare il segmento
\newcommand*{\segmento}[3][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		col draw/.initial, % il colore con cui si disegna il lato
		mark/.initial = none, % il segno da mettere al segmento
		mark size/.initial = 0.2, % la dimensione del segno
		col mark/.initial = black, % il colore del segno
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		arrow/.initial, % può essere ->, <-, <-> (o lasciata vuota)
		name path/.initial, % può essere usato per dare un nome al path
		lbl/.initial,
		lbl name/.initial, % il nome da dare alla posizione del label
		lbl dist/.initial = 0.2, % la distanza da aggiungere al raggio
		lbl size/.initial,
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\PRIVsegmento[
		PRIV col=\kv{col},
		PRIV col draw=\kv{col draw},
		PRIV mark=\kv{mark},
		PRIV mark size=\kv{mark size},
		PRIV col mark=\kv{col mark},
		PRIV width=\kv{width},
		PRIV pattern=\kv{pattern},
		PRIV arrow=\kv{arrow},
		PRIV name path=\kv{name path},
		PRIV lbl=\kv{lbl},
		PRIV lbl name=\kv{lbl name},
		PRIV lbl dist=\kv{lbl dist},
		PRIV lbl size=\kv{lbl size},
		PRIV lbl col=\kv{lbl col},
		PRIV col lbl=\kv{col lbl},
	]{#2}{#3};
}

% chiama come \PRIVsegmento[keys]{A}{B} per disegnare il segmento (versione privata, per il solo programmatore)
\newcommand*{\PRIVsegmento}[3][]{
	\tikzset{keyfld/.cd,
		PRIV col/.initial,
		PRIV col draw/.initial, % il colore con cui si disegna il lato
		PRIV mark/.initial = none, % il segno da mettere al segmento
		PRIV mark size/.initial = 0.2, % la dimensione del segno
		PRIV col mark/.initial = black, % il colore del segno
		PRIV width/.initial, % può essere thin, thick, ...
		PRIV pattern/.initial, % può essere solid, dashed, dotted, ...
		PRIV arrow/.initial, % può essere ->, <-, <-> (o lasciata vuota)
		PRIV name path/.initial, % può essere usato per dare un nome al path
		PRIV lbl/.initial,
		PRIV lbl name/.initial, % il nome da dare alla posizione del label
		PRIV lbl dist/.initial = 0.2, % la distanza da aggiungere al raggio
		PRIV lbl size/.initial,
		PRIV lbl col/.initial,
		PRIV col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\setkeyvalueifempty{PRIV lbl name}{segmentoLabelPos}
	\copykeyvalueifempty{PRIV col draw}{PRIV col};
	\coordinate(segmentoA)at(#2);
	\coordinate(segmentoB)at(#3);
	\ifkeyempty{PRIV name path}
		{\draw[\kv{PRIV col draw},\kv{PRIV width},\kv{PRIV pattern},\kv{PRIV arrow}](segmentoA)--(segmentoB);}
		{\draw[\kv{PRIV col draw},\kv{PRIV width},\kv{PRIV pattern},\kv{PRIV arrow},name path=\kv{PRIV name path}](segmentoA)--(segmentoB);}
	\tkzMarkSegment[mark=\kv{PRIV mark},\kv{PRIV col mark},size=\kv{PRIV mark size}cm](segmentoA,segmentoB)
	\medio{segmentoPuntoMedio}{segmentoA}{segmentoB};
	\ruotapuntoN[\kv{PRIV lbl dist}]{\kv{PRIV lbl name}}{segmentoA}{segmentoPuntoMedio}{90};
	\PRIVstylelbl[
		PRIVlbl lbl=\kv{PRIV lbl},
		PRIVlbl lbl size=\kv{PRIV lbl size},
		PRIVlbl lbl name=\kv{PRIV lbl name},
		PRIVlbl col=\kv{PRIV col},
		PRIVlbl lbl col=\kv{PRIV lbl col},
		PRIVlbl col lbl=\kv{PRIV col lbl},
	]{\kv{PRIV lbl name}};
}

% chiama come \markarco[keys]{mark}{O}{A}{B} per creare un mark nel punto medio dell'arco di circonferenza AB di centro O. m indica il marchio richiesto (fra s,z,x,o,oo,|,||,|||)
\newcommand*{\markarco}[5][]{
	\tikzset{keyfld/.cd,
		col/.initial = black,
		size/.initial = 0.2, % la dimensione del segno
	} \setkeyfld{#1};
	\piedebis[markarcoPiedeBisettriceTemp]{markarcoPiedeBisettrice}{#4}{#3}{#5};
	\distanza{\markarcoRaggioCirconferenza}{#3}{#4};
	\verso[\markarcoRaggioCirconferenza]{markarcoPuntoMedioArco}{#3}{markarcoPiedeBisettrice};
	\ruotapuntoN{markarcoEstremoP}{#3}{markarcoPuntoMedioArco}{+90};
	\ruotapuntoN{markarcoEstremoM}{#3}{markarcoPuntoMedioArco}{-90};
	\tkzMarkSegment[mark=#2,\kv{col},size=\kv{size}cm](markarcoEstremoP,markarcoEstremoM)
}

% chiama come \angolo[keys]{A}{B}{C} per disegnare l'angolo in senso antiorario
\newcommand*{\angolo}[4][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		col draw/.initial, % il colore con cui si disegna l'angolo
		r/.initial = 0.6, % il raggio dell'angolo
		mark/.initial = none, % il segno da mettere all'angolo
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		arrow/.initial, % può essere ->, <-, <-> (o lasciata vuota)
		fill/.initial = false, fill/.default = true, % può essere true o false
		col fill/.initial, % il colore del filling
		opacity/.initial = 30, % un numero fra 0 e 1 che indica l'intensità della colorazione
		lbl/.initial,
		lbl dist/.initial = 0.2, % la distanza da aggiungere al raggio
		lbl size/.initial,
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\PRIVangolo[
		PRIV col=\kv{col},
		PRIV col draw=\kv{col draw},
		PRIV r=\kv{r},
		PRIV mark=\kv{mark},
		PRIV width=\kv{width},
		PRIV pattern=\kv{pattern},
		PRIV arrow=\kv{arrow},
		PRIV fill=\kv{fill},
		PRIV col fill=\kv{col fill},
		PRIV opacity=\kv{opacity},
		PRIV lbl=\kv{lbl},
		PRIV lbl dist=\kv{lbl dist},
		PRIV lbl size=\kv{lbl size},
		PRIV lbl col=\kv{lbl col},
		PRIV col lbl=\kv{col lbl},
	]{#2}{#3}{#4};
}

% chiama come \PRIVangolo[keys]{A}{B}{C} per disegnare l'angolo in senso antiorario
\newcommand*{\PRIVangolo}[4][]{
	\tikzset{keyfld/.cd,
		PRIV col/.initial,
		PRIV col draw/.initial, % il colore con cui si disegna l'angolo
		PRIV r/.initial = 0.6, % il raggio dell'angolo
		PRIV mark/.initial = none, % il segno da mettere all'angolo
		PRIV width/.initial, % può essere thin, thick, ...
		PRIV pattern/.initial, % può essere solid, dashed, dotted, ...
		PRIV arrow/.initial, % può essere ->, <-, <-> (o lasciata vuota)
		PRIV fill/.initial = false, % può essere true o false
		PRIV col fill/.initial, % il colore del filling
		PRIV opacity/.initial = 30, % un numero fra 0 e 1 ch indica l'intensità della colorazione
		PRIV lbl/.initial,
		PRIV lbl dist/.initial = 0.2, % la distanza da aggiungere al raggio
		PRIV lbl size/.initial,
		PRIV lbl col/.initial,
		PRIV col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\copykeyvaluesifempty
		{PRIV col draw}{PRIV col}
		{PRIV col lbl}{PRIV col}
		{PRIV lbl col}{PRIV col lbl}
	\ifkeyempty{PRIV col fill}{}{\setkeyvalue{PRIV fill}{true}};
	\ifkeyequal{PRIV fill}{true}{\copykeyvalueifempty{PRIV col fill}{PRIV col}}{};
	\coordinate(angoloPuntoA)at(#2);
	\coordinate(angoloPuntoB)at(#3);
	\coordinate(angoloPuntoC)at(#4);
	\ifkeyequal{PRIV fill}{true}{\tkzFillAngle[size=\kv{PRIV r},opacity=\kv{PRIV opacity}*0.01,fill=\kv{PRIV col fill}](angoloPuntoA,angoloPuntoB,angoloPuntoC)}{}
	\tkzMarkAngle[mark=\kv{PRIV mark},size=\kv{PRIV r},draw=\kv{PRIV col draw},\kv{PRIV width},\kv{PRIV pattern},\kv{PRIV arrow}](angoloPuntoA,angoloPuntoB,angoloPuntoC)
	\tkzLabelAngle[pos=(\kv{PRIV r}+\kv{PRIV lbl dist}),\kv{PRIV lbl col}](angoloPuntoA,angoloPuntoB,angoloPuntoC){\kv{PRIV lbl size}\kv{PRIV lbl}}
}

% chiama come \angoloretto[keys]{A}{B}{C} per disegnare l'angolo retto in senso antiorario
\newcommand*{\angoloretto}[4][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		col draw/.initial, % il colore con cui si disegna l'angolo
		r/.initial = 0.4, % il lato del segmento del quadratino
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		arrow/.initial, % può essere ->, <-, <-> (o lasciata vuota)
		fill/.initial = false, fill/.default = true, % può essere true o false
		col fill/.initial, % il colore del filling
		opacity/.initial = 30, % un numero fra 0 e 1 ch indica l'intensità della colorazione
	} \setkeyfld{#1};
	\setkeyvalueifempty{col draw}{\kv{col}};
	\ifkeyempty{col fill}{}{\setkeyvalue{fill}{true}};
	\ifkeyequal{fill}{true}{\setkeyvalueifempty{col fill}{\kv{col}}}{};
	\coordinate(angolorettoPuntoA)at(#2);
	\coordinate(angolorettoPuntoB)at(#3);
	\coordinate(angolorettoPuntoC)at(#4);
	\ifkeyequal{fill}{true}
	{\tkzMarkRightAngle[size=\kv{r},\kv{width},\kv{pattern},fill=\kv{col fill},opacity=\kv{opacity}*0.01](angolorettoPuntoA,angolorettoPuntoB,angolorettoPuntoC)}{}
	\tkzMarkRightAngle[size=\kv{r},draw=\kv{col draw},\kv{width},\kv{pattern},\kv{arrow}](angolorettoPuntoA,angolorettoPuntoB,angolorettoPuntoC)
}


%%%%%%%%%%%%%%%%	RETTE E SEMIRETTE

% \retta[keys]{A}{B} crea una retta da A a B
\newcommand*{\retta}[3][]{
	\tikzset{keyfld/.cd,
		draw length/.initial,
		prol length/.initial = 0.8,
		col/.initial,
		width/.initial, % può essere thin, thick, ...
		pattern draw/.initial, % può essere solid, dashed, dotted, ...
		pattern prol/.initial = dashed, % può essere solid, dashed, dotted, ...
		name path/.initial, % può essere usato per dare un nome al path (per il tratto continuo)
		lbl/.initial,
		lbl name/.initial = rettaLblName, % il nome da dare alla posizione del label
		lbl dist/.initial = 0.2, % la distanza da aggiungere al raggio
		mirror lbl/.initial = false, mirror lbl/.default = true, % dice se vogliamo ribaltare la posizione del label
		lbl size/.initial,
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\ifkeyempty{draw length}{
		\ifkeyempty{name path}
			{\draw[\kv{col},\kv{width},\kv{pattern draw}](#2)--(#3);}
			{\draw[\kv{col},\kv{width},\kv{pattern draw},name path=\kv{name path}](#2)--(#3);}
		\allont[\kv{prol length}]{rettaProlA}{#2}{#3};
		\allont[\kv{prol length}]{rettaProlB}{#3}{#2};
		\draw[\kv{col},\kv{width},\kv{pattern prol}] (#2)--(rettaProlA) (#3)--(rettaProlB);
	}{
		\allont[\kv{draw length}]{rettaDrawA}{#2}{#3};
		\allont[\kv{draw length}]{rettaDrawB}{#3}{#2};
		\ifkeyempty{name path}
			{\draw[\kv{col},\kv{width},\kv{pattern draw}](rettaDrawA)--(#2)--(#3)--(rettaDrawB);}
			{\draw[\kv{col},\kv{width},\kv{pattern draw},name path=\kv{name path}](rettaDrawA)--(#2)--(#3)--(rettaDrawB);}
		\allont[\kv{prol length}]{rettaProlA}{rettaDrawA}{#3};
		\allont[\kv{prol length}]{rettaProlB}{rettaDrawB}{#2};
		\draw[\kv{col},\kv{width},\kv{pattern prol}] (rettaDrawA)--(rettaProlA) (rettaDrawB)--(rettaProlB);
	}
	\verso[0.2]{rettaFulcro}{rettaProlB}{#2};
	\ifkeyequal{mirror lbl}{false}{\def\semirettaLblAng{-90}}{\def\semirettaLblAng{+90}}
	\ruotapuntoN[\kv{lbl dist}]{\kv{lbl name}}{rettaProlB}{rettaFulcro}{\semirettaLblAng};
	\PRIVstylelbl[
		PRIVlbl lbl=\kv{lbl},
		PRIVlbl lbl size=\kv{lbl size},
		PRIVlbl lbl name=\kv{lbl name},
		PRIVlbl col=\kv{col},
		PRIVlbl lbl col=\kv{lbl col},
		PRIVlbl col lbl=\kv{col lbl},
	]{\kv{lbl name}};
}

% \semiretta[keys]{A}{B} crea una semiretta da A a B
\newcommand*{\semiretta}[3][]{
	\tikzset{keyfld/.cd,
		draw length/.initial,
		prol length/.initial = 0.8,
		col/.initial,
		width/.initial, % può essere thin, thick, ...
		pattern draw/.initial, % può essere solid, dashed, dotted, ...
		pattern prol/.initial = dashed, % può essere solid, dashed, dotted, ...
		name path/.initial, % può essere usato per dare un nome al path (per il tratto continuo)
		lbl/.initial,
		lbl name/.initial = semirettaLblName, % il nome da dare alla posizione del label
		lbl dist/.initial = 0.2, % la distanza da aggiungere al raggio
		mirror lbl/.initial = false, mirror lbl/.default = true, % dice se vogliamo ribaltare la posizione del label
		lbl size/.initial,
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\ifkeyempty{draw length}{
		\ifkeyempty{name path}
			{\draw[\kv{col},\kv{width},\kv{pattern draw}](#2)--(#3);}
			{\draw[\kv{col},\kv{width},\kv{pattern draw},name path=\kv{name path}](#2)--(#3);}
		\allont[\kv{prol length}]{semirettaProlTo}{#3}{#2};
		\draw[\kv{col},\kv{width},\kv{pattern prol}](#3)--(semirettaProlTo);
	}{
		\allont[\kv{draw length}]{semirettaDrawTo}{#3}{#2};
		\ifkeyempty{name path}
			{\draw[\kv{col},\kv{width},\kv{pattern draw}](#2)--(#3)--(semirettaDrawTo);}
			{\draw[\kv{col},\kv{width},\kv{pattern draw},name path=\kv{name path}](#2)--(#3)--(semirettaDrawTo);}
		\allont[\kv{prol length}]{semirettaProlTo}{semirettaDrawTo}{#2};
		\draw[\kv{col},\kv{width},\kv{pattern prol}](semirettaDrawTo)--(semirettaProlTo);
	}
	\verso[0.2]{semirettaFulcro}{semirettaProlTo}{#2};
	\ifkeyequal{mirror lbl}{false}{\def\semirettaLblAng{-90}}{\def\semirettaLblAng{+90}}
	\ruotapuntoN[\kv{lbl dist}]{\kv{lbl name}}{semirettaProlTo}{semirettaFulcro}{\semirettaLblAng};
	\PRIVstylelbl[
		PRIVlbl lbl=\kv{lbl},
		PRIVlbl lbl size=\kv{lbl size},
		PRIVlbl lbl name=\kv{lbl name},
		PRIVlbl col=\kv{col},
		PRIVlbl lbl col=\kv{lbl col},
		PRIVlbl col lbl=\kv{col lbl},
	]{\kv{lbl name}};
}


%%%%%%%%%%%%%%%%	CIRCONFERENZE

% chiama come \circCR[keys]{C}{R} per disegnare la circonferenza di centro C e raggio R
\newcommand*{\circCR}[3][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		name path/.initial, % può essere usato per dare un nome al path
		fill/.initial = false, fill/.default = true,
		col fill/.initial,
		opacity/.initial = 30, % l'opacity del fill, se non è stato specificato col fill
		lbl name/.initial = circCPlblName, % il nome da dare all'eventuale label (se presente)
		lbl/.initial,
		lbl size/.initial,
		lbl dist/.initial = 0.3, % la distanza del label dalla circonferenza
		lbl ang/.initial = -150, % l'angolo a cui mettere il label
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\ifkeyequal{fill}{true}{\setkeyvalueifempty{col fill}{\kv{col}!\kv{opacity}};}
	\ifkeyequal{pattern}{path}{
		\ifkeyempty{name path}{
			\ifkeyempty{col fill}
			{\path (#2) circle (#3);}
			{\path[fill=\kv{col fill}] (#2) circle (#3);}
		}{
			\ifkeyempty{col fill}
			{\path[name path=\kv{name path}] (#2) circle (#3);}
			{\path[name path=\kv{name path},fill=\kv{col fill}] (#2) circle (#3);}
		}
	}{
		\ifkeyempty{name path}{
			\ifkeyempty{col fill}
			{\draw[\kv{col},\kv{width},\kv{pattern}] (#2) circle (#3);}
			{\draw[\kv{col},\kv{width},\kv{pattern},fill=\kv{col fill}] (#2) circle (#3);}
		}{
			\ifkeyempty{col fill}
			{\draw[\kv{col},\kv{width},\kv{pattern},name path=\kv{name path}] (#2) circle (#3);}
			{\draw[\kv{col},\kv{width},\kv{pattern},name path=\kv{name path},fill=\kv{col fill}] (#2) circle (#3);}
		}
	}
	\PRIVstylelbl[
		PRIVlbl lbl=\kv{lbl},
		PRIVlbl lbl size=\kv{lbl size},
		PRIVlbl lbl name=\kv{lbl name},
		PRIVlbl col=\kv{col},
		PRIVlbl lbl col=\kv{lbl col},
		PRIVlbl col lbl=\kv{col lbl},
	]{$(#2)+(\kv{lbl ang}:#3+\kv{lbl dist} cm)$};
}

% \circCP[keys]{C}{P} disegna la circonferenza di centro C e passante per P
\newcommand*{\circCP}[3][]{\circCPr[#1]{#2}{#3}{\circCPmisuraraggio};}

% \circCPr[keys]{C}{P}{<- r} disegna la circonferenza di centro C e passante per P. Registra in r la misura del raggio della circonferenza (in cm)
\newcommand*{\circCPr}[4][]{
	\distanza{#4}{#2}{#3};
	\circCR[#1]{#2}{#4 cm};
}

% \circPPP[keys]{A}{B}{C} disegna la circonferenza passante per i tre punti A, B e C
\newcommand*{\circPPP}[4][]{\circPPPcr[#1]{#2}{#3}{#4}{circPPPcentro}{\circPPPmisuraraggio};}
% \circPPPc[keys]{A}{B}{C}{<- centro} disegna la circonferenza passante per i tre punti A, B e C
\newcommand*{\circPPPc}[5][]{\circPPPcr[#1]{#2}{#3}{#4}{#5}{\circPPPmisuraraggio};}
% \circPPPr[keys]{A}{B}{C}{<- raggio} disegna la circonferenza passante per i tre punti A, B e C
\newcommand*{\circPPPr}[5][]{\circPPPcr[#1]{#2}{#3}{#4}{circPPPcentro}{#5};}

% \circPPPcr[keys]{A}{B}{C}{<- centro}{<- raggio} disegna la circonferenza passante per i tre punti A, B e C e registra il centro e il raggio della circonferenza
\newcommand*{\circPPPcr}[6][]{
	\circocentro{#5}{#2}{#3}{#4};
	\circCPr[#1]{#5}{#2}{#6};
}


%%%%%%%%%%%%%%%%	PUNTI DA CIRCONFERENZE

% \interLC{<- P1}{<- P2}{A}{B}{O}{\R} trova i due punti di intersezione P1 e P2 fra la retta AB e la circonferenza di centro O e raggio \R
\newcommand*{\interLC}[6]{
	\path[name path=interLCcirconferenza](#5)circle(#6);
	\distanza{\interLCdistAO}{#3}{#5};
	\tikzdef\interLCdiffraggisign{sign(\interLCdistAO cm-#6 cm});
	\ifnum\interLCdiffraggisign=-1 % se A è interno alla circonferenza
		\allont[2*#6]{interLCdistAOpuntofuori}{#3}{#4};
		\path[name path=interLCABsegmento](#3)--(interLCdistAOpuntofuori);
		\intpaths{#1}{interLCcirconferenza}{interLCABsegmento};
		\verso[2*#6]{interLCdistAOpuntofuori}{#3}{#4};
		\path[name path=interLCABsegmento](#3)--(interLCdistAOpuntofuori);
		\intpaths{#2}{interLCcirconferenza}{interLCABsegmento};
	\fi
	\ifnum\interLCdiffraggisign=1 % se A è esterno alla circonferenza
		\proj{interLCproj}{#5}{#3}{#4};
		\path[name path=interLCABsegmento](#3)--(interLCproj);
		\intpaths{#1}{interLCcirconferenza}{interLCABsegmento};
		\allont[2*#6]{interLCdistAOpuntofuori}{interLCproj}{#3};
		\path[name path=interLCABsegmento](interLCproj)--(interLCdistAOpuntofuori);
		\intpaths{#2}{interLCcirconferenza}{interLCABsegmento};
	\fi
	\ifnum\interLCdiffraggisign=0 % se A appartiene alla circonferenza
		\coordinate(#1)at(#3);
		\proj{interLCproj}{#5}{#3}{#4};
		\opposto{#2}{#3}{interLCproj};
	\fi
}

% \interCC{<- P1}{<- P2}{O1}{\R1}{O2}{\R2} trova i due punti di intersezione P1 e P2 fra le due circonferenze di centri O1 e O2 e raggi \R1 e \R2
\newcommand*{\interCC}[6]{
	\coordinate(interCCcentroA)at(#3);
	\coordinate(interCCcentroB)at(#5);
	\coordinate(interCCpuntosucirconferenzaA)at($(#3)+(#4,0)$);
	\coordinate(interCCpuntosucirconferenzaB)at($(#5)+(#6,0)$);
	\tkzInterCC(interCCcentroA,interCCpuntosucirconferenzaA)(interCCcentroB,interCCpuntosucirconferenzaB)
		\tkzGetPoints{#1}{#2}
}

%\tangentiPC{<- Ta}{<- Tb}{P}{O}{\R} trova i punti Ta e Tb sulla circonferenza di centro O e raggio \R tali per cui PTa e PTb sono tangenti alla circonferenza
\newcommand*{\tangentiPC}[5]{
	\medio{tangentiPCmedio}{#3}{#4};
	\distanza{\tangentiPCraggioPO}{tangentiPCmedio}{#3};
	\interCC{#1}{#2}{tangentiPCmedio}{\tangentiPCraggioPO}{#4}{#5};
}

% \PtangenzaCC{<- P}{O1}{\R1}{O2}{\R2} trova il punto P da cui escono le tangenti comuni alle due circonferenze di centri O1 e O2 e raggi \R1 e \R2
\newcommand*{\PtangenzaCC}[5]{
	\tikzdef\PtangenzaCCsorterR{sign(#3-#5});
	\ifnum\PtangenzaCCsorterR=0
		\errmessage{Le due circonferenze date in input a PtangenzaCC hanno uguale raggio #3}
	\else
		\ifnum\PtangenzaCCsorterR=-1
			\PtangenzaCC{#1}{#4}{#5}{#2}{#3}; % bisogna scambiarli. Il programma infatti assume \R1>\R2
		\else
			\distanza{\PtangenzaCCd}{#2}{#4};
			\tikzdef\PtangenzaCCdsign{sign(\PtangenzaCCd)};
			\ifnum\PtangenzaCCdsign=0
				\errmessage{Le due circonferenze date in input a PtangenzaCC hanno lo stesso centro}
			\else
				\tikzdef\PtangenzaCCx{\PtangenzaCCd*#5/(#3-#5)};
				\allont[\PtangenzaCCx]{#1}{#4}{#2};
			\fi
		\fi
	\fi
}


%%%%%%%%%%%%%%%%	ARCHI DI CIRCONFERENZA

% questi comandi disegnano archi in senso antiorario (rilevante per eventuali frecce)

% \arcocirc[opzioni]{O}{A}{B} disegna un arco di circonferenza di centro O che va da A alla semiretta OB
\newcommand*{\arcocirc}[4][]{
	\coordinate(arcocircO)at(#2);
	\coordinate(arcocircA)at(#3);
	\coordinate(arcocircB)at(#4);
	\tkzDrawArc[#1](arcocircO,arcocircA)(arcocircB);
}
% \arcocircang[opzioni]{O}{A}{ang} disegna un arco di circonferenza di centro O che parte da A e ruota di un angolo ang
\newcommand*{\arcocircang}[4][]{
	\coordinate(arcocircangO)at(#2);
	\coordinate(arcocircangA)at(#3);
	\tkzDrawArc[#1,rotate](arcocircangO,arcocircangA)(#4);
}

% \semicirc[opzioni]{A}{B} disegna una semicirconferenza di diametro AB
\newcommand*{\semicirc}[3][]{
	\medio{semicircCentro}{#2}{#3};
	\arcocircang[#1]{semicircCentro}{#2}{180};
}


%%%%%%%%%%%%%%%%	ALTRE CONICHE

% \ellisse[opzioni]{centro}{semiasse a}{semiasse b}
\newcommand*{\ellisse}[4][]{\draw[#1](#2)ellipse(#3cm and #4cm);}

% \ellisserot[opzioni]{centro}{semiasse a}{semiasse b}{ang}
\newcommand*{\ellisserot}[5][]{\draw[#1,rotate around={#5:(#2)}](#2)ellipse(#3cm and #4cm);}

% \parabolaVPP[opzioni]{V}{P1}{P2} disegna un tratto di parabola con vertice V con estremi in P1 e P2. Serve che V sia fra P1 e P2. In realtà vengono disegnati due archi di parabola. \parabolaVPPy è identico a \parabolaVPP
\newcommand*{\parabolaVPP}[4][]{\parabolaVPPy[#1]{#2}{#3}{#4};}
\newcommand*{\parabolaVPPy}[4][]{
	\draw[#1](#2)parabola(#3);
	\draw[#1](#2)parabola(#4);
}

% \parabolaVPPx[opzioni]{V}{P1}{P2} è analogo a \parabolaVPPy per parabole con l'asse di simmetria parallelo all'asse x
\newcommand*{\parabolaVPPx}[4][]{
	\coordinate(parabolaVPPxPuno)at(#3);
	\coordinate(parabolaVPPxPdue)at(#4);
	\begin{rotazione}[#2]{-90}
		\parabolaVPPy[#1]{#2}{parabolaVPPxPuno}{parabolaVPPxPdue}{-90};
	\end{rotazione}
}

% \conicaeq[keys]{fromx:tox}{a}{b}{c}{d}{e} disegna la conica ax^2+by^2+cx+dy+e=0 nel range specificato per x
\newcommand*{\conicaeq}[7][]{\conicageneq[#1]{#2}{#3}{#4}{0}{#5}{#6}{#7};}

% \conicageneq[keys]{fromx:tox}{a}{b}{c}{d}{e}{f} disegna la conica ax^2+by^2+cxy+dx+ey+f=0 nel range specificato per x
\newcommand*{\conicageneq}[8][]{
	\ifnum#4=0
		\plot[#1]{#2}{\x}{-((#3)*(\x)^2+(#6)*(\x)+(#8))/((#5)*(\x)+(#7))};
	\else
		\plot[#1]{#2}{\x}{(-(#5)*(\x)-(#7)-sqrt(((#5)*(\x)+(#7))^2-4*(#4)*((#3)*(\x)^2+(#6)*(\x)+(#8))))/(2*(#4))};
		\plot[#1]{#2}{\x}{(-(#5)*(\x)-(#7)+sqrt(((#5)*(\x)+(#7))^2-4*(#4)*((#3)*(\x)^2+(#6)*(\x)+(#8))))/(2*(#4))};
	\fi
}

% \parabolaeq[opzioni]{from:to}{a}{b}{c} (e \parabolaeqy, che è identico) disegna un ramo di parabola di equazione y=ax^2+bx+c. La funzione \parabolaeqx[opzioni]{from:to}{a}{b}{c} è analoga per disegnare il ramo di parabola x=ay^2+by+c (questa volta il range è inteso su y)
\newcommand*{\parabolaeq}[5][]{\parabolaeqy[#1]{#2}{#3}{#4}{#5};}
\newcommand*{\parabolaeqy}[5][]{\plot[#1]{#2}{\x}{(#3)*(\x)^2+(#4)*(\x)+(#5)};}
\newcommand*{\parabolaeqx}[5][]{\plot[#1]{#2}{(#3)*(\x)^2+(#4)*(\x)+(#5)}{\x};}

% \ellisseeq[opzioni]{a}{b}{c}{d}{e} disegna un'ellisse di equazione ax^2+by^2+cx+dy+e=0
\newcommand*{\ellisseeq}[6][]{
	\tikzdef\ellisseeqzerodeg{0.25*(#4)*(#4)/(#2)+0.25*(#5)*(#5)/(#3)-(#6)};
	\tikzdef\ellisseeqsemiassea{sqrt(\ellisseeqzerodeg/(#2))};
	\tikzdef\ellisseeqsemiasseb{sqrt(\ellisseeqzerodeg/(#3))};
	\ellisse[#1]{-0.5*(#4)/(#2),-0.5*(#5)/(#3)}{\ellisseeqsemiassea}{\ellisseeqsemiasseb};
}

% \propinv[opzioni]{fromx:tox}{fromy:toy}{k} disegna una funzione del tipo x*y=k tenendo solo i punti (x,y) per cui x e y rientrano (entrambi) nei range specificati
\newcommand*{\propinv}[4][]{
	\extractcoordpair[:]{\propinvfromx}{\propinvtox}{#2};
	\extractcoordpair[:]{\propinvfromy}{\propinvtoy}{#3};
	\tikzdef\propinvfromyx{abs(#4)/\propinvfromy};
	\tikzdef\propinvtoyx{abs(#4)/\propinvtoy};
	\plot[#1]{\propinvfromx:\propinvfromyx}{\x}{(#4)/\x};
	\plot[#1]{\propinvtoyx:\propinvtox}{\x}{(#4)/\x};
}

% \propinvshift[opzioni]{fromx:tox}{fromy:toy}{k}{shift} è analogo a \propinv ma shiftato di shift
\newcommand*{\propinvshift}[5][]{\propinv[#1,shift={(#5)}]{#2}{#3}{#4};}


%%%%%%%%%%%%%%%%	PLOT GENERICI

% chiama come \plot[opzioni]{from:to}{x}{y}. È parametrizzato come \x
\newcommand*{\plot}[4][]{\draw[smooth,samples=100,domain=#2,#1] plot ({#3},{#4});}

% chiama come \plotcos[opzioni]{from:to}{ampiezza} o come \plotsin[opzioni]{from:to}{ampiezza}
\newcommand*{\plotcos}[3][]{\plot[#1]{#2}{\x}{(#3)*cos(\x*180/pi)};}
\newcommand*{\plotsin}[3][]{\plot[#1]{#2}{\x}{(#3)*sin(\x*180/pi)};}

% chiama come \plotcosshift[opzioni]{from:to}{ampiezza}{shift} o come \plotsinshift[opzioni]{from:to}{ampiezza}{shift}
\newcommand*{\plotcosshift}[4][]{\plotcos[#1,shift={(#4)}]{#2}{#3};}
\newcommand*{\plotsinshift}[4][]{\plotsin[#1,shift={(#4)}]{#2}{#3};}

% chiama come \plotcosfr[opzioni]{from:to}{ampiezza}{N} o come \plotsinfr[opzioni]{from:to}{ampiezza}{N} dove N indica il numero di oscillazioni per ogni unità di x
\newcommand*{\plotcosfr}[4][]{\plot[#1]{#2}{\x}{(#3)*cos(\x*360*#4)};}
\newcommand*{\plotsinfr}[4][]{\plot[#1]{#2}{\x}{(#3)*sin(\x*360*#4)};}


%%%%%%%%%%%%%%%%	UTILS

% \extractcoordpair[separatore]{<- \x}{<-  \y}{P} estrae le due coordinate di P e le scrive in \x e in \y. Se P è dato in coordinate polari o rappresenta un range allora il separatore da usare è : (anziché ,)
% #4 deve essere escritto esplicitamente. Quindi possiamo scrivere #4 come (3,5), ma non come P
\newcommand*{\extractcoordpair}[4][,]{
	\def\extractcoordpairseparator{#1}
	\def\extractcoordpairx{}
	\def\extractcoordpairy{}
	\extractcoordpairIterFist#4\extractcoordpairseparator
	\tikzdef#2{\extractcoordpairx}
	\tikzdef#3{\extractcoordpairy}
}
\newcommand*{\extractcoordpairIterFist}[1]{
	\if\extractcoordpairseparator#1 
		\expandafter\extractcoordpairIterSecond
	\else 
		\estendistr\extractcoordpairx{#1}
		\expandafter\extractcoordpairIterFist
	\fi
}
\newcommand*{\extractcoordpairIterSecond}[1]{
	\if\extractcoordpairseparator#1 \else
		\estendistr\extractcoordpairy{#1}
		\expandafter\extractcoordpairIterSecond
	\fi
}

% \estendistr#1{#2} aggiunge #2 alla fine della stringa #1
\def\estendistr#1#2{\expandafter\def\expandafter#1\expandafter{#1#2}}

\newcounter{poligonoNumPointsBuilder}

% \poligono[opzioni]{A,B,C,...} disegna un poligono
\newcommand*{\poligono}[2][]{
	\def\poligonoInputBuilder{(} % la stringa (A)--(B)--(C)--(A) Viene costruita progressivamente
	\def\poligonoFirstPointBuilder{} % la stringa A
	\setcounter{poligonoNumPointsBuilder}{1}
	\poligonoIter#2;
	\draw[#1]\poligonoInputBuilder;
}
% necessario per la funzione \poligono
\newcommand*{\poligonoIter}[1]{
	\ifx;#1\estendistr\poligonoInputBuilder{)--(\poligonoFirstPointBuilder)}\else
		\ifx,#1\estendistr\poligonoInputBuilder{)--(}\stepcounter{poligonoNumPointsBuilder}\else
			\estendistr\poligonoInputBuilder{#1}
			\ifnum\thepoligonoNumPointsBuilder=1
				\estendistr\poligonoFirstPointBuilder{#1}
			\fi
		\fi
		\expandafter\poligonoIter
	\fi
}

% \poligonale[opzioni]{A,B,C,...} disegna una poligonale (una linea spezzata)
\newcommand*{\poligonale}[2][]{
	\def\poligonaleInputBuilder{(} % la stringa (A)--(B)--(C) Viene costruita progressivamente
	\poligonaleIter#2;
	\draw[#1]\poligonaleInputBuilder;
}
% necessario per la funzione \poligonale
\newcommand*{\poligonaleIter}[1]{
	\ifx;#1\estendistr\poligonaleInputBuilder{)}\else
		\ifx,#1\estendistr\poligonaleInputBuilder{)--(}\else
			\estendistr\poligonaleInputBuilder{#1}
		\fi
		\expandafter\poligonaleIter
	\fi
}

% \carrucola[keys]{centro}{raggio esterno} disegna una carrucola
\newcommand*{\carrucola}[3][]{
	\tikzset{keyfld/.cd,
		col1/.initial = gray!70, % il colore della parte più esterna
		col2/.initial = gray, % il colore della parte intermedia
		col3/.initial = black, % il colore della parte interna
		r2/.initial = 2/3, % che percentuale di carrucola (come raggio) viene coperta dai due cerchi centrali
		r3/.initial = 1/10, % che percentuale di carrucola (come raggio) viene coperta dal cerchio centrale
	} \setkeyfld{#1};
	\draw[\kv{col3},fill=\kv{col1}] (#2) circle (#3);
	\draw[\kv{col2},fill=\kv{col2}] (#2) circle (#3*\kv{r2});
	\draw[\kv{col3},fill=\kv{col3}] (#2) circle (#3*\kv{r3});
}

% \cassa[keys]{punto iniziale}{lunghezza x}{lunghezza y}{angolo}
\newcommand*{\cassa}[5][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		col draw/.initial,
		col fill/.initial,
		opacity/.initial = 10,
		no fill/.initial = false, no fill/.default = true,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		centro/.initial = cassacentro, % dove registrare il nome del centro della cassa
		lbl/.initial,
		lbl size/.initial,
		lbl col/.initial = black,
		col lbl/.initial,
	} \setkeyfld{#1};
	\setkeyvaluesifempty
		{col draw}{\kv{col}}
		{col fill}{\kv{col}!\kv{opacity}}
	\ifkeyequal{no fill}{false}{\fill[\kv{col fill}] (#2)--++(#5:#3)--++(#5+90:#4)--++(#5+180:#3)--++(#5+270:#4);}{}
	\draw[\kv{col draw},\kv{width},\kv{pattern}] (#2)--++(#5:#3)--++(#5+90:#4)--++(#5+180:#3)--++(#5+270:#4);
	\PRIVstylelbl[
		PRIVlbl lbl=\kv{lbl},
		PRIVlbl lbl size=\kv{lbl size},
		PRIVlbl lbl name=\kv{centro},
		PRIVlbl lbl col=\kv{lbl col},
		PRIVlbl col lbl=\kv{col lbl},
	]{$(#2)+(#5:0.5*#3)+(#5+90:0.5*#4)$};
}

% \raggioluce[keys]{P1}{P2}{P3}... disegna un raggio di luce (con le varie frecce)
\makeatletter
\newcommand*{\raggioluce}[3][]{
	\tikzset{keyfld/.cd,
		col/.initial = orange,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		arrow/.initial = ->, % può essere ->, <-, <-> (o lasciata vuota)
		arrow dist/.initial = 0.8, % a che distanza percentuale mettere la freccia
	} \setkeyfld{#1};
	\medio[\kv{arrow dist}]{raggioluceposizionefreccia}{#2}{#3};
	\draw[\kv{col},\kv{width},\kv{pattern},\kv{arrow}] (#3)--(raggioluceposizionefreccia) (#2)--(raggioluceposizionefreccia);
	\@ifnextchar\bgroup{\expandafter\raggioluce[#1]{#3}}{}
}
\makeatother

% chiama come \graffa[keys]{A}{B} (se mirror resta false, gira in senso antiorario).
\newcommand*{\graffa}[3][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		shape/.initial = brace,
		amplitude/.initial = 5, % in pt
		dist/.initial = 0.05, % la distanza della molla dai punti A e B
		mirror/.initial = false, mirror/.default = true,
		lbl name/.initial = graffanamelbl,
		lbl/.initial,
		lbl col/.initial,
		col lbl/.initial,
		lbl dist/.initial = 0.5,
	} \setkeyfld{#1};
	\ifkeyequal{mirror}{false}{
		\ruotapuntoN[\kv{dist}]{graffapuntoA}{#2}{#3}{+90};
		\ruotapuntoN[\kv{dist}]{graffapuntoB}{#3}{#2}{-90};
	}{
		\ruotapuntoN[\kv{dist}]{graffapuntoA}{#3}{#2}{+90};
		\ruotapuntoN[\kv{dist}]{graffapuntoB}{#2}{#3}{-90};
	}
	\draw[\kv{col},\kv{width},\kv{pattern},decorate,decoration={\kv{shape},amplitude=\kv{amplitude}pt}](graffapuntoA) --(graffapuntoB);
	\medio{graffaPM}{graffapuntoA}{graffapuntoB};
	\ifkeyequal{mirror}{false}{\def\graffaanglbl{90};}{\def\graffaanglbl{270};}	
	\ifkeyequal{mirror}{false}
	{\ruotapunto{graffapuntoruotato}{graffapuntoB}{graffaPM}{\graffaanglbl};}
	{\ruotapunto{graffapuntoruotato}{graffapuntoA}{graffaPM}{\graffaanglbl};}
	\verso[\kv{lbl dist}]{graffalblpos}{graffaPM}{graffapuntoruotato};
	\PRIVstylelbl[
		PRIVlbl lbl=\kv{lbl},
		PRIVlbl lbl size=\kv{lbl size},
		PRIVlbl lbl name=\kv{lbl name},
		PRIVlbl col=\kv{col},
		PRIVlbl lbl col=\kv{lbl col},
		PRIVlbl col lbl=\kv{col lbl},
	]{graffalblpos};
}

% \molla[keys]{A}{B} disegna una molla da A a B
\newcommand*{\molla}[3][]{
	\tikzset{keyfld/.cd,
		col/.initial = gray,
		width/.initial, % può essere thin, thick, ...
		scale/.initial = 1,
		s/.initial, % equivalente a scale
		step/.initial = 0.15,
		r/.initial = 0.2,
		aspect/.initial = 0.3,
	} \setkeyfld{#1};
	\copykeyvalueifempty{s}{scale};
	\draw[\kv{col},\kv{width},decoration={aspect=\kv{aspect}, segment length=\kv{scale}*\kv{step}cm,amplitude=\kv{s}*\kv{r}cm,coil},decorate] (#3) -- (#2);
}

% \sfera[colore]{centro}{raggio} crea una sfera tridimensionale
\newcommand*{\sfera}[3][teal]{\shade[ball color=#1] (#2) circle (#3);}


%%%%%%%%%%%%%%%% 	DISEGNI ARTICOLATI

% \casetta[keys]{pos} disegna una casetta. pos è il centro della base della casetta
\newcommand*{\casetta}[2][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		scale/.initial = 1,
		s/.initial, % equivalente a scale
		w/.initial, % la larghezza della casetta (del tetto)
		h/.initial, % l'altezza della casetta
		x/.initial, % equivalente a width
		y/.initial, % equivalente a height
	} \setkeyfld{#1};
	\copykeyvalueifempty{s}{scale};
	\setkeyvaluesifempty
		{w}{0.6*\kv{s}}
		{h}{1.0*\kv{s}}
		{x}{\kv{w}}
		{y}{\kv{h}}
	\draw[\kv{col},\kv{width},\kv{pattern}] ($(#2)+(+0.3*\kv{x},0.88*\kv{y})$)--++(0,0.12*\kv{y})--++(-0.1*\kv{x},0)--++(0,-0.08*\kv{y}); % camino
	\draw[\kv{col},\kv{width},\kv{pattern}] ($(#2)+(-0.1*\kv{x},0)$)--++(0,0.3*\kv{y})--++(-0.15*\kv{x},0)--++(0,-0.3*\kv{y}); % porta
	\draw[\kv{col},\kv{width},\kv{pattern}] ($(#2)+(0.1*\kv{x},0.15*\kv{y})$)rectangle++(0.2*\kv{x},0.12*\kv{y}) ($(#2)+(0.2*\kv{x},0.15*\kv{y})$)--++(0,0.12*\kv{y}); % finestra in basso a destra
	\draw[\kv{col},\kv{width},\kv{pattern}] ($(#2)+(0.1*\kv{x},0.55*\kv{y})$)rectangle++(0.2*\kv{x},0.12*\kv{y}) ($(#2)+(0.2*\kv{x},0.55*\kv{y})$)--++(0,0.12*\kv{y}); % finestra in alto a destra
	\draw[\kv{col},\kv{width},\kv{pattern}] ($(#2)+(-0.1*\kv{x},0.55*\kv{y})$)rectangle++(-0.2*\kv{x},0.12*\kv{y}) ($(#2)+(-0.2*\kv{x},0.55*\kv{y})$)--++(0,0.12*\kv{y}); % finestra in alto a sinistra
	\draw[\kv{col},\kv{width},\kv{pattern}] ($(#2)+(-0.4*\kv{x},0.8*\kv{y})$)--++(0,-0.8*\kv{y})--++(0.8*\kv{x},0)--++(0,0.8*\kv{y}); % corpo
	\draw[\kv{col},\kv{width},\kv{pattern}] ($(#2)+(-0.5*\kv{x},0.8*\kv{y})$)--++(0.5*\kv{x},0.2*\kv{y})--++(0.5*\kv{x},-0.2*\kv{y})--++(-\kv{x},0); % tetto
}

% \uomo[keys]{pos} disegna un omino stilizzato. pos è il centro della sua base
\newcommand*{\uomo}[2][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		width/.initial = thick, % può essere thin, thick, ...
		h/.initial = 1, % l'altezza dell'omino
		side/.initial = ->, % può essere settato a <- se vogliamo misurare gli angoli in senso orario da ore 9 (anziché misurarle in senso orario da ore 3)
		mirror/.initial = false, mirror/.default = true, % se specificata flippa l'immagine
		lung braccio/.initial = 0.3, % il braccio è lungo \kv{lung braccio}*\kv{h}
		ang braccio/.initial, % equivalente a ang braccio 1
		ang gamba/.initial, % equivalente a ang gamba 1
		ang braccio 1/.initial = 0, % l'angolo con cui disegnare il primo braccio
		ang braccio 2/.initial, % se lasciato vuoto non viene disegnato
		ang gamba 1/.initial = -60, % l'angolo della prima gamba
		ang gamba 2/.initial = -90, % l'angolo della seconda gamba
		mano 1/.initial = ManoDx, % il nome da dare alla prima mano
		mano 2/.initial = ManoSx, % il nome da dare alla seconda mano (se disegnata)
		piede 1/.initial = PiedeDx, % il nome da dare del primo piede
		piede 2/.initial = PiedeSx, % il nome da dare del primo piede
		scale/.initial = 1,
		s/.initial, % equivalente a scale
	} \setkeyfld{#1};
	\copykeyvalueifempty{s}{scale};
	\ifkeyempty{ang braccio}{}{\copykeyvalue{ang braccio 1}{ang braccio};}
	\ifkeyempty{ang gamba}{}{\copykeyvalue{ang gamba 1}{ang gamba};}
	\ifkeyequal{side}{->}
		{\ifkeyequal{mirror}{false}{\def\uomomirrorper{}}{\def\uomomirrorper{180-}}}
		{\ifkeyequal{mirror}{true}{\def\uomomirrorper{}}{\def\uomomirrorper{180-}}}
	\tikzdef\uomoh{\kv{s}*\kv{h}}
	\draw[\kv{col},\kv{width}]($(#2)+(0,0.9*\uomoh)$)circle(0.1*\uomoh); % testa
	\draw[\kv{col},\kv{width}]($(#2)+(0,0.8*\uomoh)$)--++(0,-0.1*\uomoh); % collo
	\draw[\kv{col},ultra thick]($(#2)+(0,0.7*\uomoh)$)--++(0,-0.3*\uomoh); % corpo
	\draw[\kv{col},\kv{width}]($(#2)+(0,0.7*\uomoh)$)--++(\uomomirrorper\kv{ang braccio 1}:\kv{lung braccio}*\uomoh)node(\kv{mano 1}){}; % braccio 1
	\ifkeyempty{ang braccio 2}{}{\draw[\kv{col},\kv{width}]($(#2)+(0,0.7*\uomoh)$)--++(\uomomirrorper\kv{ang braccio 2}:\kv{lung braccio}*\uomoh)node(\kv{mano 2}){};} % braccio 2
	\intrette{\kv{piede 1}}{#2}{$(#2)+(1,0)$}{$(#2)+(0,0.4*\uomoh)$}{$(#2)+(0,0.4*\uomoh)+(\uomomirrorper\kv{ang gamba 1}:1)$}; % la posizione del primo piede
	\intrette{\kv{piede 2}}{#2}{$(#2)+(1,0)$}{$(#2)+(0,0.4*\uomoh)$}{$(#2)+(0,0.4*\uomoh)+(\uomomirrorper\kv{ang gamba 2}:1)$}; % la posizione del secondo piede
	\draw[\kv{col},\kv{width}](\kv{piede 1})--($(#2)+(0,0.4*\uomoh)$)--(\kv{piede 2}); % le gambe
}

% \donna[keys]{pos} disegna una donnina stilizzata. pos è il centro della sua base
\newcommand*{\donna}[2][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		width/.initial = thick, % può essere thin, thick, ...
		h/.initial = 1, % l'altezza dell'omino
		side/.initial = ->, % può essere settato a <- se vogliamo misurare gli angoli in senso orario da ore 9 (anziché misurarle in senso orario da ore 3)
		mirror/.initial = false, mirror/.default = true, % se specificata flippa l'immagine
		lung braccio/.initial = 0.3, % il braccio è lungo \kv{lung braccio}*\kv{h}
		ang braccio/.initial, % equivalente a ang braccio 1
		ang gamba/.initial, % equivalente a ang gamba 1
		ang braccio 1/.initial = 0, % l'angolo con cui disegnare il primo braccio
		ang braccio 2/.initial, % se lasciato vuoto non viene disegnato
		ang gamba 1/.initial = -60, % l'angolo della prima gamba
		ang gamba 2/.initial = -90, % l'angolo della seconda gamba
		mano 1/.initial = ManoDx, % il nome da dare alla prima mano
		mano 2/.initial = ManoSx, % il nome da dare alla seconda mano (se disegnata)
		piede 1/.initial = PiedeDx, % il nome da dare del primo piede
		piede 2/.initial = PiedeSx, % il nome da dare del primo piede
		scale/.initial = 1,
		s/.initial, % equivalente a scale
	} \setkeyfld{#1};
	\copykeyvalueifempty{s}{scale};
	\ifkeyempty{ang braccio}{}{\copykeyvalue{ang braccio 1}{ang braccio};}
	\ifkeyempty{ang gamba}{}{\copykeyvalue{ang gamba 1}{ang gamba};}
	\ifkeyequal{side}{->}
		{\ifkeyequal{mirror}{false}{\def\donnamirrorper{}}{\def\donnamirrorper{180-}}}
		{\ifkeyequal{mirror}{true}{\def\donnamirrorper{}}{\def\donnamirrorper{180-}}}
	\tikzdef\donnah{\kv{s}*\kv{h}}
	\draw[\kv{col},\kv{width}]($(#2)+(0,0.9*\donnah)$)circle(0.1*\donnah); % testa
	\draw[\kv{col},\kv{width}]($(#2)+(0,0.8*\donnah)$)--++(0,-0.1*\donnah); % collo
	\draw[\kv{col},ultra thick]($(#2)+(0,0.7*\donnah)$)--++(0,-0.3*\donnah); % corpo
	\draw[\kv{col},\kv{width}]($(#2)+(0,0.4*\donnah)$)--++(-0.2*\donnah,-0.2*\donnah)--++(+0.4*\donnah,0)--++(-0.2*\donnah,+0.2*\donnah); % gonna
	\draw[\kv{col},\kv{width}]($(#2)+(0,0.7*\donnah)$)--++(\donnamirrorper\kv{ang braccio 1}:\kv{lung braccio}*\donnah)node(\kv{mano 1}){}; % braccio 1
	\ifkeyempty{ang braccio 2}{}{\draw[\kv{col},\kv{width}]($(#2)+(0,0.7*\donnah)$)--++(\donnamirrorper\kv{ang braccio 2}:\kv{lung braccio}*\donnah)node(\kv{mano 2}){};} % braccio 2
	\intrette{\kv{piede 1}}{#2}{$(#2)+(1,0)$}{$(#2)+(0,0.4*\donnah)$}{$(#2)+(0,0.4*\donnah)+(\donnamirrorper\kv{ang gamba 1}:1)$}; % la posizione del primo piede
	\intrette{\kv{piede 2}}{#2}{$(#2)+(1,0)$}{$(#2)+(0,0.4*\donnah)$}{$(#2)+(0,0.4*\donnah)+(\donnamirrorper\kv{ang gamba 2}:1)$}; % la posizione del secondo piede
	\medio{GambaDxGonna}{\kv{piede 1}}{$(#2)+(0,0.4*\donnah)$};
	\medio{GambaSxGonna}{\kv{piede 2}}{$(#2)+(0,0.4*\donnah)$};
	\draw[\kv{col},\kv{width}](GambaDxGonna)--(\kv{piede 1}) (GambaSxGonna)--(\kv{piede 2}); % le gambe
}

% \auto[keys]{pos} disegna un'automobile. pos è il centro della sua base
\newcommand*{\auto}[2][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		width/.initial = thick, % può essere thin, thick, ...
		side/.initial = ->, % può essere settato a <- se vogliamo ribaltare l'auto
		mirror/.initial = false, mirror/.default = true, % se specificata flippa l'immagine
		w/.initial = 3, % la lunghezza dell'auto
		h/.initial = 2, % l'altezza dell'auto
		x/.initial, % equivalente a w
		y/.initial, % equivalente a h
		scale/.initial = 1, % la scala da usare
		s/.initial, % equivalente a s
		ang/.initial, % se specificato l'auto viene ruotata di questo angolo attorno a #2
	} \setkeyfld{#1};
	\ifkeyempty{ang}{
	\copykeyvaluesifempty
		{x}{w}
		{y}{h}
		{s}{scale}
	\ifkeyequal{side}{->}
		{\ifkeyequal{mirror}{false}{\def\automirrorper{+1}}{\def\automirrorper{-1}}}
		{\ifkeyequal{mirror}{true}{\def\automirrorper{+1}}{\def\automirrorper{-1}}}
	\tikzdef{\autosizex}{\automirrorper*\kv{s}*\kv{x}/30};
	\tikzdef{\autosizey}{\kv{s}*\kv{y}/20};
	% ruote
	\coordinate(autocentroruotaposteriore)at($(#2)+(-9*\autosizex,2*\autosizey)$);
	\coordinate(autocentroruotaanteriore)at($(#2)+(+4.5*\autosizex,2*\autosizey)$);
	\draw[\kv{col},\kv{width}](autocentroruotaposteriore)circle(2*\autosizey);
	\draw[\kv{col},\kv{width}](autocentroruotaanteriore)circle(2*\autosizey);
	\draw[\kv{col},\kv{width},fill=\kv{col}](autocentroruotaposteriore)circle(0.2*\autosizey);
	\draw[\kv{col},\kv{width},fill=\kv{col}](autocentroruotaanteriore)circle(0.2*\autosizey);
	\coordinate(autobottomfront)at($(#2)+(12*\autosizex,2.4*\autosizey)$);
	\coordinate(autobottomback)at($(#2)+(-15*\autosizex,2.4*\autosizey)$);
	\interLC{autoruotaanteriorefront}{autoruotaanterioreback}{autobottomfront}{autobottomback}{autocentroruotaanteriore}{2.4*\autosizey};
	\interLC{autoruotaposteriorefront}{autoruotaposterioreback}{autobottomfront}{autobottomback}{autocentroruotaposteriore}{2.4*\autosizey};
	\ifkeyequal{side}{->}{
		\arcocirc[\kv{col},\kv{width}]{autocentroruotaposteriore}{autoruotaposteriorefront}{autoruotaposterioreback};
		\arcocirc[\kv{col},\kv{width}]{autocentroruotaanteriore}{autoruotaanteriorefront}{autoruotaanterioreback};
	}{
		\arcocirc[\kv{col},\kv{width}]{autocentroruotaposteriore}{autoruotaposterioreback}{autoruotaposteriorefront};
		\arcocirc[\kv{col},\kv{width}]{autocentroruotaanteriore}{autoruotaanterioreback}{autoruotaanteriorefront};
	}
	%carrozzeria
	\draw[\kv{col},\kv{width},rounded corners=\kv{s}*0.5mm] (autoruotaposteriorefront)--(autoruotaanterioreback) (autoruotaanteriorefront)--(autobottomfront)--($(#2)+(15*\autosizex,5*\autosizey)$)--++(0,2*\autosizey)--++(-6*\autosizex,3*\autosizey)--++(0,10*\autosizey)--($(#2)+(-15*\autosizex,20*\autosizey)$)--(autobottomback)--(autoruotaposterioreback);
	}{ %se dobbiamo ruotare l'auto
		\begin{rotazione}[#2]{\kv{ang}} \auto[#1,ang=]{#2} \end{rotazione}
	}
}

% \camion[keys]{pos} disegna un camion. pos è il centro della sua base
\newcommand*{\camion}[2][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		width/.initial = thick, % può essere thin, thick, ...
		side/.initial = ->, % può essere settato a <- se vogliamo ribaltare il camion
		mirror/.initial = false, mirror/.default = true, % se specificata flippa l'immagine
		w/.initial = 6, % la lunghezza del camion
		h/.initial = 3, % l'altezza del camion
		x/.initial, % equivalente a w
		y/.initial, % equivalente a h
		scale/.initial = 1, % la scala da usare
		s/.initial, % equivalente a s
		ang/.initial, % se specificato il camion viene ruotato di questo angolo attorno a #2
	} \setkeyfld{#1};
	\ifkeyempty{ang}{
	\copykeyvaluesifempty
		{x}{w}
		{y}{h}
		{s}{scale}
	\ifkeyequal{side}{->}
		{\ifkeyequal{mirror}{false}{\def\camionmirrorper{+1}}{\def\camionmirrorper{-1}}}
		{\ifkeyequal{mirror}{true}{\def\camionmirrorper{+1}}{\def\camionmirrorper{-1}}}
	\tikzdef{\camionsizex}{\camionmirrorper*\kv{s}*\kv{x}/60};
	\tikzdef{\camionsizey}{\kv{s}*\kv{y}/30};
	% ruote
	\coordinate(camioncentroruotaposteriore)at($(#2)+(-24*\camionsizex,3*\camionsizey)$);
	\coordinate(camioncentroruotaanteriore)at($(#2)+(+21*\camionsizex,3*\camionsizey)$);
	\draw[\kv{col},\kv{width}](camioncentroruotaposteriore)circle(3*\camionsizey);
	\draw[\kv{col},\kv{width}](camioncentroruotaanteriore)circle(3*\camionsizey);
	\draw[\kv{col},\kv{width},fill=\kv{col}](camioncentroruotaposteriore)circle(0.2*\camionsizey);
	\draw[\kv{col},\kv{width},fill=\kv{col}](camioncentroruotaanteriore)circle(0.2*\camionsizey);
	\coordinate(camionbottomfront)at($(#2)+(+30*\camionsizex,3.6*\camionsizey)$);
	\coordinate(camionbottomback)at($(#2)+(-30*\camionsizex,3.6*\camionsizey)$);
	\interLC{camionruotaanteriorefront}{camionruotaanterioreback}{camionbottomfront}{camionbottomback}{camioncentroruotaanteriore}{3.6*\camionsizey};
	\interLC{camionruotaposteriorefront}{camionruotaposterioreback}{camionbottomfront}{camionbottomback}{camioncentroruotaposteriore}{3.6*\camionsizey};
	\ifkeyequal{side}{->}{
		\arcocirc[\kv{col},\kv{width}]{camioncentroruotaposteriore}{camionruotaposteriorefront}{camionruotaposterioreback};
		\arcocirc[\kv{col},\kv{width}]{camioncentroruotaanteriore}{camionruotaanteriorefront}{camionruotaanterioreback};
	}{
		\arcocirc[\kv{col},\kv{width}]{camioncentroruotaposteriore}{camionruotaposterioreback}{camionruotaposteriorefront};
		\arcocirc[\kv{col},\kv{width}]{camioncentroruotaanteriore}{camionruotaanterioreback}{camionruotaanteriorefront};
	}
	%carrozzeria
	\draw[\kv{col},\kv{width}] (camionruotaposteriorefront)--(camionruotaanterioreback) (camionruotaanteriorefront)--(camionbottomfront)--($(#2)+(30*\camionsizex,6*\camionsizey)$)--++(-\camionsizex,0) (camionruotaposterioreback)--(camionbottomback)--++(0,9*\camionsizey)--++(45*\camionsizex,0)--++(0,17.4*\camionsizey)--++(-43.5*\camionsizex,0)--++(0,-17.4*\camionsizey);
	\draw[\kv{col},\kv{width},rounded corners=\kv{s}*0.5mm] ($(#2)+(29*\camionsizex,6*\camionsizey)$)--++(0,6*\camionsizey)--++(-3*\camionsizex,0)--++(0,12*\camionsizey)--++(-11*\camionsizex,0);
	}{ %se dobbiamo ruotare il camion
		\begin{rotazione}[#2]{\kv{ang}} \camion[#1,ang=]{#2} \end{rotazione}
	}
}

% \moto[keys]{pos} disegna un motociclista. pos è il centro della base della moto
\newcommand*{\moto}[2][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		width/.initial = thick, % può essere thin, thick, ...
		side/.initial = ->, % può essere settato a <- se vogliamo ribaltare la moto
		mirror/.initial = false, mirror/.default = true, % se specificata flippa l'immagine
		w/.initial = 2, % la lunghezza della moto
		h/.initial = 1.5, % l'altezza della moto (col motociclista)
		x/.initial, % equivalente a w
		y/.initial, % equivalente a h
		scale/.initial = 1, % la scala da usare
		s/.initial, % equivalente a s
		ang/.initial, % se specificato la moto viene ruotata di questo angolo attorno a #2
	} \setkeyfld{#1};
	\ifkeyempty{ang}{
	\copykeyvaluesifempty
		{x}{w}
		{y}{h}
		{s}{scale}
	\ifkeyequal{side}{->}
		{\ifkeyequal{mirror}{false}{\def\motomirrorper{+1}}{\def\motomirrorper{-1}}}
		{\ifkeyequal{mirror}{true}{\def\motomirrorper{+1}}{\def\motomirrorper{-1}}}
	\tikzdef{\motosizex}{\motomirrorper*\kv{s}*\kv{x}/20};
	\tikzdef{\motosizey}{\kv{s}*\kv{y}/15};
	\coordinate(motocentroruotaposteriore)at($(#2)+(-10*\motosizex+\motomirrorper*2*\motosizey,2*\motosizey)$);
	\coordinate(motocentroruotaanteriore)at($(#2)+(+10*\motosizex-\motomirrorper*2*\motosizey,2*\motosizey)$);
	\draw[\kv{col},\kv{width}](motocentroruotaposteriore)circle(2*\motosizey);
	\draw[\kv{col},\kv{width}](motocentroruotaanteriore)circle(2*\motosizey);
	\draw[\kv{col},\kv{width},fill=\kv{col}](motocentroruotaposteriore)circle(0.2*\motosizey);
	\draw[\kv{col},\kv{width},fill=\kv{col}](motocentroruotaanteriore)circle(0.2*\motosizey);
	\ifkeyequal{side}{->}
	{\coordinate(motofrontattachpoint)at($(#2)+(+10*\motosizex-\motomirrorper*2*\motosizey,3*\motosizey)+(110:3*\motosizey)$);}
	{\coordinate(motofrontattachpoint)at($(#2)+(+10*\motosizex-\motomirrorper*2*\motosizey,3*\motosizey)+(70:3*\motosizey)$);}
	\draw[\kv{col},\kv{width}](motocentroruotaanteriore)--(motofrontattachpoint);
	\draw[\kv{col},\kv{width}](motocentroruotaposteriore)--($(motocentroruotaanteriore)+(-\motomirrorper*3*\motosizey,0)$)--++(0,\motosizey)arc(90+\motomirrorper*90:90:3*\motosizey)--++(\motosizex,0)arc(90-\motomirrorper*90:90:4*\motosizey)--++(0,-2*\motosizey)--++(-4*\motosizex,0)arc(90:90+\motomirrorper*90:\motosizey cm and 2*\motosizey cm)--++(-5*\motosizex,0)--++(-\motosizex,\motosizey)--++(-4*\motosizex,0)--++(0,-\motosizey)arc(90:90-\motomirrorper*90:5*\motosizey cm and 3*\motosizey cm)--++(0,-\motosizey);
	\draw[\kv{col},\kv{width}]($(#2)+(-4*\motosizex,3*\motosizey)$)--++(5*\motosizex,2*\motosizey)--++(-4*\motosizex,\motosizey)--++(5*\motosizex,5*\motosizey)node(motocollopunto){}++(-\motosizex,-\motosizey)--++(4*\motosizex,-3*\motosizey)node(motomanubriopunto){};
	\draw[\kv{col},\kv{width},fill=\kv{col}](motomanubriopunto)circle(0.1*\motosizey);
	\coordinate(motocentrocasco)at($(motocollopunto)+(0,2*\motosizey)$);
	\draw[\kv{col},\kv{width}]($(motocentrocasco)+(90-\motomirrorper*60:2*\motosizey)$)--($(motocentrocasco)+(0,\motosizey)$)--($(motocentrocasco)+(0,-\motosizey)$)--($(motocentrocasco)+(-90+\motomirrorper*60:2*\motosizey)$);
	\draw[\kv{col},\kv{width}](motocentrocasco)circle(2*\motosizey);
	}{ %se dobbiamo ruotare la moto
		\begin{rotazione}[#2]{\kv{ang}} \moto[#1,ang=]{#2} \end{rotazione}
	}
}

% \bici[keys]{pos} disegna un ciclista. pos è il centro della base della bicicletta
\newcommand*{\bici}[2][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		width/.initial = thick, % può essere thin, thick, ...
		side/.initial = ->, % può essere settato a <- se vogliamo ribaltare la bicicletta
		mirror/.initial = false, mirror/.default = true, % se specificata flippa l'immagine
		w/.initial = 1.6, % la lunghezza della bicicletta
		h/.initial = 2, % l'altezza della bicicletta (col ciclista)
		x/.initial, % equivalente a w
		y/.initial, % equivalente a h
		scale/.initial = 1, % la scala da usare
		s/.initial, % equivalente a s
		ang/.initial, % se specificato la bici viene ruotata di questo angolo attorno a #2
	} \setkeyfld{#1};
	\ifkeyempty{ang}{
	\copykeyvaluesifempty
		{x}{w}
		{y}{h}
		{s}{scale}
	\ifkeyequal{side}{->}
		{\ifkeyequal{mirror}{false}{\def\bicimirrorper{+1}}{\def\bicimirrorper{-1}}}
		{\ifkeyequal{mirror}{true}{\def\bicimirrorper{+1}}{\def\bicimirrorper{-1}}}
	\tikzdef{\bicisizey}{\kv{s}*\kv{y}/20};
	\tikzdef{\bicisizex}{\bicimirrorper*\bicisizey};
	\coordinate(bicicentroruotaposteriore)at($(#2)+(-0.5*\bicimirrorper*\kv{s}*\kv{x}+3*\bicisizex,+3*\bicisizey)$);
	\coordinate(bicicentroruotaanteriore)at($(#2)+(+0.5*\bicimirrorper*\kv{s}*\kv{x}-3*\bicisizex,+3*\bicisizey)$);
	\draw[\kv{col},\kv{width}](bicicentroruotaposteriore)circle(3*\bicisizey);
	\draw[\kv{col},\kv{width}](bicicentroruotaanteriore)circle(3*\bicisizey);
	\coordinate(bicicatena)at($(bicicentroruotaposteriore)+(4*\bicisizex,0)$);
	\coordinate(bicifulcro)at($(bicicatena)+(-4*\bicisizex*4/7,4*\bicisizey)$);
	\draw[\kv{col},\kv{width}](bicicentroruotaanteriore)--++(-\bicisizex,4*\bicisizey)--++(-\bicisizex,-0.25*\bicisizey)--++(0.5*\bicisizex,2*\bicisizey)node(bicifrontpoint){}--++(\bicisizex,+0.25*\bicisizey)--++(0,\bicisizey);
	\draw[\kv{col},\kv{width}](bicicatena)--($(bicifrontpoint)+(0.25*\bicisizex,-\bicisizey)$)--(bicifulcro)--(bicicentroruotaposteriore)--(bicicatena)--++(-2*\bicisizex,7*\bicisizey)node(bicisellino){};
	\draw[\kv{col},\kv{width}]($(bicisellino)+(-\bicisizex,0)$)--++(2*\bicisizex,0);
	\draw[\kv{col},\kv{width},fill=\kv{col}](bicicentroruotaposteriore)circle(0.3*\bicisizey);
	\draw[\kv{col},\kv{width},fill=\kv{col}](bicicentroruotaanteriore)circle(0.3*\bicisizey);
	\draw[\kv{col},\kv{width},fill=\kv{col}](bicicatena)circle(0.7*\bicisizey);
	\draw[\kv{col},\kv{width}](bicicatena)--++(2*\bicisizex,5*\bicisizey)--++(-3*\bicisizex,2*\bicisizey)--++(-1.6*\bicisizex,0)--++(2.5*\bicisizex,6*\bicisizey)node(bicicollo){}++(-0.5*\bicisizex,-\bicisizey)--($(bicifrontpoint)+(\bicisizex,+0.75*\bicisizey)$);
	\draw[\kv{col},\kv{width}]($(bicicollo)+(0,2*\bicisizey)$)circle(2*\bicisizey);
	}{ %se dobbiamo ruotare la bici
		\begin{rotazione}[#2]{\kv{ang}} \bici[#1,ang=]{#2} \end{rotazione}
	}
}