% Questo è il pacchetto liLaTeX per tikz

\usepackage{tkz-euclide} % per alcune funzioni grafiche (come \intrette)
\usepackage{pgfplots} % pacchetto per plot
\pgfplotsset{compat=1.17} % necessario per compatibilità con versioni precedenti

%%%%%%%%%%%%%%%% AMBIENTE immagine

% le immagini vengono generalmente create fra \begin{immagine}[opzioni] e \end{immagine}
\newenvironment{immagine}[1][]
	{\ifdefstring{\TipoDoc}{immagine}{}{\begin{figure}[!ht]\centering}\begin{tikzpicture}[#1]}
	{\end{tikzpicture}\ifdefstring{\TipoDoc}{immagine}{}{\end{figure}}}

% analogo ad immagine, ma permette di aggiungere una caption
\newenvironment{immaginecap}[2][]
	{\def\immaginecapCaption{#2}\begin{figure}[!ht]\centering\begin{tikzpicture}[#1]}
	{\end{tikzpicture}\caption{\immaginecapCaption}\end{figure}}
\newenvironment{immaginecap*}[2][]
	{\def\immaginecapCaption{#2}\begin{figure}[!ht]\centering\begin{tikzpicture}[#1]}
	{\end{tikzpicture}\caption*{\immaginecapCaption}\end{figure}}
	
% \begin{rotazione}[centro rotazione]{ang}picture\end{rotazione} disegna l'immagine ruotata
% Attenzione! una coordinata fornita come (1,2) verrà ruotata, ma una coordinata data come P non verrà ruotata. È un comportamento un po' anomalo, ma il rotate around di tikz funziona in questo modo
\newenvironment{rotazione}[2][0,0]
	{\begin{scope}[rotate around={#2:(#1)}]}
	{\end{scope}}


%%%%%%%%%%%%%%%% KEY MANAGER

% da chiamare all'inizio di qualunque comando con dei parametri opzionali come \setkeyfld{parametri opzionali}. Dovrebbe essere sempre la seconda riga di qualunque newcommand con parametri opzionali
\newcommand{\setkeyfld}[1]{
	% passiamo alla key directory keyfld, e ridefiniamo come #1 tutti le keys specificate in #1
	\tikzset{keyfld/.cd,#1}%
	% definiamo un soprannome \kv per il path alle keys. In questo modo, per riferirci al VALORE di una chiave chiamata K dovremo scrivere \kv{K}, anziché la più lunga /tikz/keyfld/K. Quindi K indica la chiave, mentre \kv{K} indica il suo valore
	\def\kv##1{\pgfkeysvalueof{/tikz/keyfld/##1}}
}

% ifkeyequal{keyname}{value to compare}{do if equal}{do if different}
\newcommand{\ifkeyequal}[4]{
	\edef\ifkeyequalkey{\kv{#1}} 
	\edef\ifkeyequalcomp{#2}
	\ifdefequal{\ifkeyequalkey}{\ifkeyequalcomp}{#3}{#4}
}
% \ifkeyempty{keyname}{do if empty}{do if non-empty}
\newcommand{\ifkeyempty}[3]{\ifkeyequal{#1}{\pgfkeysnovalue}{#2}{#3}}

% aggiorna il valore della key #1 al valore #2. Chiama ad esempio come \setkeyvalue{color}{blue} o come \setkeyvalue{h}{\kv{b}}
\newcommand{\setkeyvalue}[2]{\tikzset{keyfld/.cd,#1=#2}}
% copia il valore della key #2 nella key #1
\newcommand{\copykeyvalue}[2]{\setkeyvalue{#1}{\kv{#2}}}
% aggiorna il valore della key #1 al valore #2 solo se #1 è empty
\newcommand{\setkeyvalueifempty}[2]{\ifkeyempty{#1}{\setkeyvalue{#1}{#2}}{}}
% aggiorna il valore della key #1 al valore \kv{#2} solo se #1 è empty
\newcommand{\copykeyvalueifempty}[2]{\setkeyvalueifempty{#1}{\kv{#2}}}

% aggiorna i valori di diverse keys se sono vuoti. Analoghi a chiamare \setkeyvalueifempty o \copykeyvalueifempty diverse volte di fila
\makeatletter
\newcommand{\setkeyvaluesifempty}[2]{\setkeyvalueifempty{#1}{#2}\@ifnextchar\bgroup{\setkeyvaluesifempty}{}}
\newcommand{\copykeyvaluesifempty}[2]{\copykeyvalueifempty{#1}{#2}\@ifnextchar\bgroup{\copykeyvaluesifempty}{}}
\makeatother


%%%%%%%%%%%%%%%% FUNZIONI

% definisce un valore numerico #1 uguale all'output dell'operazione #2
\newcommand\tikzdef[2]{\pgfmathsetmacro{#1}{#2}} % definisce float #1:=#2

% converte da pt a cm. Chiama come \convertto{cm}{misura pt}
\makeatletter
\def\convertto#1#2{\strip@pt\dimexpr #2*65536/\number\dimexpr 1#1}
\makeatother

% restituisce in output il nome del comando in input
\newcommand{\commandname}[1]{\expandafter{\string#1}}

% restituisce il nome del comando #1 senzo lo slash
\newcommand{\commandstring}[1]{\removeslash{#1}}

% rimuove lo \ dall'input
\newcommand{\removeslash}[1]{{\catcode92=9 \endlinechar-1 \scantokens{#1}}}

% calcola la distanza (in cm) fra #1 e #2
\newcommand{\getdistanza}[2]{\tkzCalcLength(#1,#2) \tkzGetLength{getdistanzaAB} \convertto{cm}{\getdistanzaAB pt}}

% registra la distanza fra #2 e #3 in #1
\newcommand{\distanza}[3]{\tkzCalcLength(#2,#3) \tkzGetLength{distanzaTemp} \def#1{\convertto{cm}{\distanzaTemp pt}};}

% angolopolare{<- \a}{P}{O} registra in \a la coordinata angolare di P in un sistema di rif. centrato in O
\newcommand{\angolopolare}[3]{
	\coordinate(angolopolareterzopunto)at($(#3)+(1,0)$);
	\tkzFindAngle(angolopolareterzopunto,#3,#2) \tkzGetAngle{angolopolareoutput} \def#1{\angolopolareoutput};
}

% \addlabel[opzioni]{P}{L}{ang} aggiunge un label L al punto P
\newcommand{\addlabel}[4][]{\tkzLabelPoint(#2){#3}}

% \stylelbl[keys]{coord} scrive il label nel formato specificato
\newcommand{\stylelbl}[2][]{
	\tikzset{keyfld/.cd,
		lbl style/.initial, % se specificato usiamo questo stile. Le opzioni sono rm, bf, cal
		lbl/.initial,
		lbl name/.initial = scriptlblName,
		col/.initial,
		lbl size/.initial,
		col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\copykeyvaluesifempty
		{lbl col}{col}
		{col lbl}{lbl col}
	\ifkeyempty{lbl}{\coordinate (\kv{lbl name}) at (#2);}{
		\ifkeyempty{lbl style}{ \node[\kv{col lbl}] (\kv{lbl name}) at (#2) {\kv{lbl size}\kv{lbl}}; }{}
		\ifkeyequal{lbl style}{rm}{ \node[\kv{col lbl}] (\kv{lbl name}) at (#2) {\kv{lbl size}$\mathrm{\kv{lbl}}$}; }{}
		\ifkeyequal{lbl style}{bf}{ \node[\kv{col lbl}] (\kv{lbl name}) at (#2) {\kv{lbl size}$\mathbf{\kv{lbl}}$}; }{}
		\ifkeyequal{lbl style}{cal}{ \node[\kv{col lbl}] (\kv{lbl name}) at (#2) {\kv{lbl size}$\mathcal{\kv{lbl}}$}; }{}
	}
}


%%%%%%%%%%%%%%%% PUNTO
% Attenzione! coordinate create come \punto (o suoi derivati) sono incompatibili con l'opzione fill per eventuali poligoni. Questo vuol dire che se vogliamo disegnare un poligono colorato, dobbiamo definire i punti come \coordinate, poi usare fill, e infine ripassare i vertici con \punto

% chiama come \punto[keys]{coordinate}
\newcommand{\punto}[2][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		size/.initial = 1.5,
		shape/.initial = circle, % circle, rettangle o lo si può lasciare vuoto
		name/.initial = puntoNome,
		lbl/.initial,
		lbl name/.initial,
		lbl ang/.initial = -90,
		lbl dist/.initial = 0.3,
		lbl size/.initial,
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\coordinate[\kv{shape},inner sep=\kv{size},fill=\kv{col}] (\kv{name}) at (#2);
	\stylelbl[#1]{$(#2)+(\kv{lbl ang}:\kv{lbl dist})$};
}

% chiama come \pnt[col]{nome}{coordinate}
\newcommand{\pnt}[3][]{\punto[name=#2,col=#1]{#3};}
% chiama come \pntlbl[col]{nome}{lbl}{lbl ang}{coordinate}
\newcommand{\pntlbl}[5][]{\punto[name=#2,lbl=#3,lbl ang=#4,col=#1]{#5};}
% chiama come \pntl[col]{name}{lbl ang}{coordinate}
\newcommand{\pntl}[4][]{\pntlbl[#1]{#2}{$#2$}{#3}{#4};}
% chiama come \pntlp[col]{name}{lbl ang}{coordinate}
\newcommand{\pntlp}[4][]{\pntlbl[#1]{#2p}{$#2'$}{#3}{#4};}
% chiama come \pntls[col]{name}{lbl ang}{coordinate}
\newcommand{\pntls}[4][]{\pntlbl[#1]{#2s}{$#2''$}{#3}{#4};}


%%%%%%%%%%%%%%%% CALCOLO DI COORDINATE

% \verso[L]{<- P}{A}{B} crea un punto P ottenuto traslando A verso B per una lunghezza complessiva L
\newcommand{\verso}[4][1]{\coordinate (#2) at ($(#3)!#1cm!(#4)$);}
% \allont[L]{<- P}{A}{B} analogo di \verso ma allontanandosi da B
\newcommand{\allont}[4][1]{\verso[-#1]{#2}{#3}{#4};}

% \parallelo[L]{<- P}{S}{A}{B} crea un punto P, ottenuto traslando S per una lunghezza L nel verso nel vettore AB
\newcommand{\parallelo}[5][1]{\coordinate (#2) at ($(#3)-(#4)+(#4)!#1cm!(#5)$);}

% \perpendicolare[L]{<- P}{S}{A}{B} crea un punto P, ottenuto traslando S per una lunghezza L nel verso perpendicolare a AB (si suppone SAB in senso antiorario)
\newcommand{\perpendicolare}[5][1]{\coordinate (#2) at ($(#3)-(#4)+(#4)!#1cm!-90:(#5)$);}

% \medio[k]{<- M}{A}{B} definisce M come il punto k*A+(1-k)*B. Nel caso speciale di k=0.5, M è il punto medio del segmento AB
\newcommand{\medio}[4][0.5]{\coordinate(#2)at($(#3)-#1*(#3)+#1*(#4)$);}

% \opposto{<- P'}{P}{O} crea l'opposto P' di P rispetto al centro di simmetria O
\newcommand{\opposto}[3]{\coordinate(#1)at($2*(#3)-(#2)$);}

% \simmetrico{<- P'}{P}{A}{B} crea il punto P', simmetrico di P rispetto alla retta di simmetria AB
\newcommand{\simmetrico}[4]{
	\proj{simmetricoPuntoDiProiezione}{#2}{#3}{#4};
	\opposto{#1}{#2}{simmetricoPuntoDiProiezione};
}

% \proj{<- H}{P}{A}{B} genera H come la proiezione ortogonale di P sulla retta AB
\newcommand{\proj}[4]{\tkzDefPointBy[projection=onto #3--#4](#2) \tkzGetPoint{#1};}

% \sumvett{<- C}{A}{B}{D} definisce il punto C in modo che il vettore AC sia uguale alla somma vettoriale AB+AD. Così facendo ABCD forma un parallelogramma
\newcommand{\sumvett}[4]{\coordinate(#1)at($(#3)-(#2)+(#4)$);}

% \ruotapunto{<- R}{P}{O}{a} definisce il punto R ottenuto ruotando P in senso antiorario di un angolo a (con centro di rotazione in O)
\newcommand{\ruotapunto}[4]{
	\coordinate(ruotapuntoP)at(#2);
	\coordinate(ruotapuntoO)at(#3);
	\tkzDefPointBy[rotation= center ruotapuntoO angle #4](ruotapuntoP) \tkzGetPoint{#1};
}

% \ruotapuntoN[L]{<- R}{P}{O}{a} dopo aver ruotato il punto, lo normalizza per farlo diventare di luunghezza L
\newcommand{\ruotapuntoN}[5][1]{
	\ruotapunto{ruotapuntoNnonnormalizzato}{#3}{#4}{#5};
	\verso[#1]{#2}{#4}{ruotapuntoNnonnormalizzato};
}

% \triangoloequilatero{<- C}{A}{B} prende in input due punti A e B, e definisce un terzo punto C in modo che ABC sia un triangolo equilatero (coi vertici scritti in senso antiorario)
\newcommand{\triangoloequilatero}[3]{\tkzDefTriangle[equilateral](#2,#3) \tkzGetPoint{#1}}


%%%%%%%%%%%%%%%% INTERSEZIONI

% \intpahts{<- I}{path1}{path2} trova il punto di intersezione fra due paths e lo chiama I
\newcommand{\intpaths}[3]{\path [name intersections={of=#2 and #3,by=#1}];}

% \intrette{<- I}{A}{B}{C}{D} trova il punto di intersezione I fra le rette AB e CD
\newcommand{\intrette}[5]{\tkzInterLL(#2,#3)(#4,#5) \tkzGetPoint{#1};}


%%%%%%%%%%%%%%%% GRIGLIE SISTEMI DI RIFERIMENTO

% \griglia[keys]{west}{east}{south}{north}
\newcommand{\griglia}[5][]{
	\tikzset{keyfld/.cd,
		col/.initial = gray,
		width/.initial = thin, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		step/.initial = 1, % la distanza fra due barre
		s/.initial, % equivalente a step
		step x/.initial, % se specificato indica la distanza fra due barre lungo l'asse x
		step y/.initial, % se specificato indica la distanza fra due barre lungo l'asse y
		s x/.initial, % analogo di step x
		s y/.initial, % analogo di step y
	} \setkeyfld{#1};
	\copykeyvaluesifempty
		{s}{step}
		{step x}{s}
		{step y}{s}
		{s x}{step x}
		{s y}{step y}
	\draw[\kv{col},\kv{width},\kv{pattern}] (#2,#4) grid [xstep=\kv{s x},ystep=\kv{s y}] (#3,#5);
}
% \grigliaZ[keys]{east}{north}
\newcommand{\grigliaZ}[3][]{\griglia[#1]{0}{#2}{0}{#3}}

% \cartamillimetrata[keys]{west}{east}{south}{north} % una porzione di carta millimetrata
\newcommand{\cartamillimetrata}[5][]{
	\tikzset{keyfld/.cd,
		col1/.initial = pink!50,
		col2/.initial = gray!70,
		width1/.initial = ultra thin, % può essere thin, thick, ...
		width2/.initial = thin, % può essere thin, thick, ...
		pattern1/.initial, % può essere solid, dashed, dotted, ...
		pattern2/.initial, % può essere solid, dashed, dotted, ...
		step1/.initial = 0.1, % la distanza fra due barre minori (normalmente 0.1)
		step2/.initial = 0.5, % la distanza fra due barre maggiori (normalmente 0.5)
	} \setkeyfld{#1};
	\draw[\kv{col1},\kv{width1},\kv{pattern1}] (#2,#4) grid [step=\kv{step1}] (#3,#5);
	\draw[\kv{col2},\kv{width2},\kv{pattern2}] (#2,#4) grid [step=\kv{step2}] (#3,#5);
}

% può solo essere usata con \TipoDoc=immagine. Crea una pagina intera di carta millimetrata
\newcommand{\cartamillimetratapagina}[1][]{\cartamillimetrata[#1]{0}{21}{0.3}{30};}

% \assex[keys]{x-left}{x-right} crea l'asse x
\newcommand{\assex}[3][]{
	\tikzset{keyfld/.cd,
		y/.initial = 0, % la y del centro
		ang shift/.initial = 0,
		col/.initial,
		arrow/.initial = ->,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		lbl/.initial = $x$,
		lbl name/.initial = assexlbl, % il nome da dare al label
		lbl dist/.initial = 0.3,
		col lbl/.initial,
		flip lbl/.initial = false, % rendi true se vuoi ribaltare il label
	} \setkeyfld{#1};
	\copykeyvalueifempty{col lbl}{col};
	\ifkeyequal{flip lbl}{true}{\def\assexflipper{180}}{\def\assexflipper{0}};
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] ($(0,\kv{y})+(\kv{ang shift}:#2)$) -- ($(0,\kv{y})+(\kv{ang shift}:#3)$)node(assexpunta){};
	\stylelbl[#1]{$(assexpunta)+(\kv{ang shift}-90+\assexflipper:\kv{lbl dist})$};
}

% \assey[keys]{y-bottom}{y-top} crea l'assey
\newcommand{\assey}[3][]{
	\tikzset{keyfld/.cd,
		x/.initial = 0, % la x del centro
		ang shift/.initial = 0,
		col/.initial,
		arrow/.initial = ->,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		lbl/.initial = $y$,
		lbl name/.initial = asseylbl, % il nome da dare al label
		lbl dist/.initial = 0.3,
		col lbl/.initial,
		flip lbl/.initial = false, % rendi true se vuoi ribaltare il label
	} \setkeyfld{#1};
	\copykeyvalueifempty{col lbl}{col};
	\ifkeyequal{flip lbl}{true}{\def\asseyflipper{180}}{\def\asseyflipper{0}};
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] ($(\kv{x},0)+(\kv{ang shift}+90:#2)$) -- ($(\kv{x},0)+(\kv{ang shift}+90:#3)$)node(asseypunta){};
	\stylelbl[#1]{$(asseypunta)+(\kv{ang shift}+180+\asseyflipper:\kv{lbl dist})$};
}

% \assixy[keys]{x-left}{x-right}{y-left}{y-right} disegna gli assi cartesiani
\newcommand{\assixy}[5][]{
	\tikzset{keyfld/.cd,
		x/.initial = 0, % la x del centro
		y/.initial = 0, % la y del centro
		col/.initial,
		arrow/.initial = ->,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		lbl x/.initial = $x$,
		lbl y/.initial = $y$,
		lbl x name/.initial = assixylblx, % il nome da dare al label per y
		lbl y name/.initial = assixylbly, % il nome da dare al label per y
		lbl dist/.initial = 0.3,
		col lbl/.initial,
	} \setkeyfld{#1};
	\assixyO[#1]{\kv{x},\kv{y}}{#2}{#3}{#4}{#5};
}

% \assixyO[keys]{centro}{x-left}{x-right}{y-left}{y-right} disegna gli assi cartesiani
\newcommand{\assixyO}[6][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		arrow/.initial = ->,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		lbl x/.initial = $x$,
		lbl y/.initial = $y$,
		lbl x name/.initial = assixylblx, % il nome da dare al label per y
		lbl y name/.initial = assixylbly, % il nome da dare al label per y
		lbl dist/.initial = 0.3,
		col lbl/.initial,
	} \setkeyfld{#1};
	\copykeyvalueifempty{col lbl}{col};
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] (#3,0|-#2)--(#4,0|-#2)node(assixypuntax){};
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] (0,#5-|#2)--(0,#6-|#2)node(assixypuntay){};
	\node[\kv{col lbl}](\kv{lbl x name}) at ($(assixypuntax)+(-90:\kv{lbl dist})$){\kv{lbl x}};
	\node[\kv{col lbl}](\kv{lbl y name}) at ($(assixypuntay)+(180:\kv{lbl dist})$){\kv{lbl y}};
}

% \assexbar[keys]{\x}{lbl}
\newcommand{\assexbar}[3][]{
	\tikzset{keyfld/.cd,
		y/.initial = 0, % la y dell'asse cartesiano
		col/.initial,
		arrow/.initial,
		width/.initial = very thin, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		size/.initial = .2, % la dimensione della barretta verticale
		col lbl/.initial,
		flip/.initial = false, % se posto a true il label viene messo verso l'alto anziché verso il basso
	} \setkeyfld{#1};
	\ifnum\value{TipoDocVerificaCounter}=0 \setkeyvalueifempty{col}{gray} \fi % se non è una verifica la barra viene colorata di grigio
	\copykeyvalueifempty{col lbl}{col};
	\ifkeyequal{flip}{false}
	{\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}](#2,\kv{y}+0.5*\kv{size})--++(0,-\kv{size})node[anchor=north,\kv{col lbl}]{#3};}
	{\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}](#2,\kv{y}-0.5*\kv{size})--++(0,+\kv{size})node[anchor=south,\kv{col lbl}]{#3};}
}

% \asseybar[keys]{\y}{lbl}
\newcommand{\asseybar}[3][]{
	\tikzset{keyfld/.cd,
		x/.initial = 0, % la x dell'asse cartesiano
		col/.initial,
		arrow/.initial,
		width/.initial = very thin, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		size/.initial = .2, % la dimensione della barretta verticale
		col lbl/.initial,
		flip/.initial = false, % se posto a true il label viene messo verso l'alto anziché verso il basso
	} \setkeyfld{#1};
	\ifnum\value{TipoDocVerificaCounter}=0 \setkeyvalueifempty{col}{gray} \fi % se non è una verifica la barra viene colorata di grigio
	\copykeyvalueifempty{col lbl}{col};
	\ifkeyequal{flip}{false}
	{\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}](\kv{x}+0.5*\kv{size},#2)--++(-\kv{size},0)node[anchor=east,\kv{col lbl}]{#3};}
	{\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}](\kv{x}-0.5*\kv{size},#2)--++(+\kv{size},0)node[anchor=west,\kv{col lbl}]{#3};}
}

% \sistrif[keys]{centro}{angolo} crea il sistema di riferimento, ruotato dell'angolo specificato. Si usa in cinematica/dinamica per indicare le direzioni e i versi degli assi cartesiani utilizzati
\newcommand{\sistrif}[3][]{
	\tikzset{keyfld/.cd,
		col/.initial = teal,
		arrow/.initial = ->,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		front/.initial = 2, % la lunghezza con cui andiamo avanti
		back/.initial = 0.3, % la lunghezza per cui andiamo indietro
		front x/.initial,
		back x/.initial,
		front y/.initial,
		back y/.initial,
		flip/.initial = false, % rendi true se vuoi capovolgere il verso dell'asse y
		label/.initial = true, % rengi false se non vuoi il label
		lbl dist/.initial = 0.3,
		lbl x/.initial = $x$,
		lbl y/.initial = $y$,
		col lbl/.initial,
	} \setkeyfld{#1};
	\copykeyvaluesifempty
		{front x}{front}
		{front y}{front}
		{back x}{back}
		{back y}{back}
		{col lbl}{col}
	\ifkeyequal{flip}{false}{\def\sistrifflipper{+1}}{\def\sistrifflipper{-1}}
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] ($(#2)+(#3:-\kv{back x})$) -- ($(#2)+(#3:\kv{front x})$)node(sistrifLblXpunta){};
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] ($(#2)+(\sistrifflipper*90+#3:-\kv{back y})$) -- ($(#2)+(\sistrifflipper*90+#3:\kv{front y})$)node(sistrifLblYpunta){};
	\ifkeyequal{label}{true}{
		\node[\kv{col lbl}](sistrifLblXlabel)at($(sistrifLblXpunta)+(#3-90*\sistrifflipper:\kv{lbl dist})$){\kv{lbl x}};
		\node[\kv{col lbl}](sistrifLblYlabel)at($(sistrifLblYpunta)+(#3+180:\kv{lbl dist})$){\kv{lbl y}};
	}{}
}


%%%%%%%%%%%%%%%% TRIANGOLI

% \piedemed[k]{<- P}{A}{B}{C} trova il piede P della mediana BP (k è un parametro fra 0 e 1 che "sposta" P lungo il lato AC)
\newcommand{\piedemed}[5][0.5]{\medio[#1]{#2}{#3}{#5};}

% \piedealt{<- P}{A}{B}{C} trova P (il piede dell'altezza BP)
\newcommand{\piedealt}[4]{\proj{#1}{#3}{#2}{#4};}

% \piedebis[temp]{<- P}{A}{B}{C} trova P (il piede della bisettrice dell'angolo ABC)
\newcommand{\piedebis}[5][piedebisTemp]{
	\tkzDefLine[bisector](#3,#4,#5) \tkzGetPoint{#1}
	\intrette{#2}{#4}{#1}{#3}{#5};
}

% \centrotriangolo[type]{<- P}{A}{B}{C} trova il centro del triangolo (funzione usata per definire i successivi 5 comandi)
\newcommand{\centrotriangolo}[5][centroid]{\tkzDefTriangleCenter[#1](#3,#4,#5) \tkzGetPoint{#2};}
% \baricentro{<- P}{A}{B}{C} trova il baricentro P di un triangolo ABC
\newcommand{\baricentro}[4]{\centrotriangolo[centroid]{#1}{#2}{#3}{#4}}
% \ortocentro{<- P}{A}{B}{C} trova il baricentro P di un triangolo ABC
\newcommand{\ortocentro}[4]{\centrotriangolo[ortho]{#1}{#2}{#3}{#4}}
% \circocentro{<- P}{A}{B}{C} trova il baricentro P di un triangolo ABC
\newcommand{\circocentro}[4]{\centrotriangolo[circum]{#1}{#2}{#3}{#4}}
% \incentro{<- P}{A}{B}{C} trova il baricentro P di un triangolo ABC
\newcommand{\incentro}[4]{\centrotriangolo[in]{#1}{#2}{#3}{#4}}
% \exocentro{<- P}{A}{B}{C} trova il baricentro P di un triangolo ABC (opposto a B)
\newcommand{\excentro}[4]{\centrotriangolo[ex]{#1}{#2}{#3}{#4}}


%%%%%%%%%%%%%%%% MARKS accettano le opzioni s,z,x,o,oo,|,||,|||

% chiama come \segmento[keys]{A}{B} per disegnare il segmento
\newcommand{\segmento}[3][]{
	\tikzset{keyfld/.cd,
		col/.initial = black,
		col draw/.initial, % il colore con cui si disegna il lato
		mark/.initial = none, % il segno da mettere al segmento
		mark size/.initial = 0.2, % la dimensione del segno
		col mark/.initial = black, % il colore del segno
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		arrow/.initial, % può essere ->, <-, <-> (o lasciata vuota)
		name path/.initial, % può essere usato per dare un nome al path
		lbl/.initial,
		lbl name/.initial, % il nome da dare alla posizione del label
		lbl dist/.initial = 0.2, % la distanza da aggiungere al raggio
		lbl size/.initial,
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\copykeyvalueifempty{col draw}{col};
	\ifkeyempty{lbl}{}{\setkeyvalueifempty{lbl name}{segmentoLabelPos};}
	\ifkeyempty{name path}
		{\draw[\kv{col draw},\kv{width},\kv{pattern},\kv{arrow}](#2)--(#3);}
		{\draw[\kv{col draw},\kv{width},\kv{pattern},\kv{arrow},name path=\kv{name path}](#2)--(#3);}
	\tkzMarkSegment[mark=\kv{mark},\kv{col mark},size=\kv{mark size}cm](#2,#3)
	\ifkeyempty{lbl name}{}{
		\medio{segmentoPuntoMedio}{#2}{#3};
		\ruotapuntoN[\kv{lbl dist}]{\kv{lbl name}}{#2}{segmentoPuntoMedio}{90};
	}
	\stylelbl[#1]{\kv{lbl name}};
}

% chiama come \markarco[keys]{m}{O}{A}{B} per creare un mark nel punto medio dell'arco di circonferenza AB di centro O. m indica il marchio richiesto (fra s,z,x,o,oo,|,||,|||)
\newcommand{\markarco}[5][]{
	\tikzset{keyfld/.cd,
		col/.initial = black,
		size/.initial = 0.2, % la dimensione del segno
	} \setkeyfld{#1};
	\piedebis[markarcoPiedeBisettriceTemp]{markarcoPiedeBisettrice}{#4}{#3}{#5};
	\distanza{\markarcoRaggioCirconferenza}{#3}{#4};
	\verso[\markarcoRaggioCirconferenza]{markarcoPuntoMedioArco}{#3}{markarcoPiedeBisettrice};
	\ruotapuntoN{markarcoEstremoP}{#3}{markarcoPuntoMedioArco}{+90};
	\ruotapuntoN{markarcoEstremoM}{#3}{markarcoPuntoMedioArco}{-90};
	\tkzMarkSegment[mark=#2,\kv{col},size=\kv{size}cm](markarcoEstremoP,markarcoEstremoM)
}

% chiama come \angolo[keys]{A}{B}{C} per disegnare l'angolo in senso antiorario
\newcommand{\angolo}[4][]{
	\tikzset{keyfld/.cd,
		col/.initial = black,
		col draw/.initial, % il colore con cui si disegna l'angolo
		r/.initial = 0.6, % il raggio dell'angolo
		mark/.initial = none, % il segno da mettere all'angolo
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		arrow/.initial, % può essere ->, <-, <-> (o lasciata vuota)
		fill/.initial = false, % può essere true o false
		col fill/.initial, % il colore del filling
		opacity/.initial = 0.3, % un numero fra 0 e 1 ch indica l'intensità della colorazione
		lbl/.initial,
		lbl dist/.initial = 0.2, % la distanza da aggiungere al raggio
		lbl size/.initial,
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\setkeyvalueifempty{col draw}{\kv{col}};
	\setkeyvalueifempty{col lbl}{\kv{col}};
	\setkeyvalueifempty{lbl col}{\kv{col lbl}};
	\ifkeyempty{col fill}{}{\setkeyvalue{fill}{true}};
	\ifkeyequal{fill}{true}{\setkeyvalueifempty{col fill}{\kv{col}}}{};
	\coordinate(angoloPuntoA)at(#2);
	\coordinate(angoloPuntoB)at(#3);
	\coordinate(angoloPuntoC)at(#4);
	\ifkeyequal{fill}{true}{\tkzFillAngle[size=\kv{r},opacity=\kv{opacity},fill=\kv{col fill}](angoloPuntoA,angoloPuntoB,angoloPuntoC)}{}
	\tkzMarkAngle[mark=\kv{mark},size=\kv{r},draw=\kv{col draw},\kv{width},\kv{pattern},\kv{arrow}](angoloPuntoA,angoloPuntoB,angoloPuntoC)
	\ifkeyempty{lbl}{}{\tkzLabelAngle[pos=\kv{r}+\kv{lbl dist},\kv{lbl col}](angoloPuntoA,angoloPuntoB,angoloPuntoC){\kv{lbl size}\kv{lbl}}}
}

% chiama come \angoloretto[keys]{A}{B}{C} per disegnare l'angolo retto in senso antiorario
\newcommand{\angoloretto}[4][]{
	\tikzset{keyfld/.cd,
		col/.initial = black,
		col draw/.initial, % il colore con cui si disegna l'angolo
		r/.initial = 0.4, % il lato del segmento del quadratino
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		arrow/.initial, % può essere ->, <-, <-> (o lasciata vuota)
		fill/.initial = false, % può essere true o false
		col fill/.initial, % il colore del filling
		opacity/.initial = 0.3, % un numero fra 0 e 1 ch indica l'intensità della colorazione
	} \setkeyfld{#1};
	\setkeyvalueifempty{col draw}{\kv{col}};
	\ifkeyempty{col fill}{}{\setkeyvalue{fill}{true}};
	\ifkeyequal{fill}{true}{\setkeyvalueifempty{col fill}{\kv{col}}}{};
	\coordinate(angolorettoPuntoA)at(#2);
	\coordinate(angolorettoPuntoB)at(#3);
	\coordinate(angolorettoPuntoC)at(#4);
	\ifkeyequal{fill}{true}
	{\tkzMarkRightAngle[size=\kv{r},\kv{width},\kv{pattern},fill=\kv{col fill},opacity=\kv{opacity}](angolorettoPuntoA,angolorettoPuntoB,angolorettoPuntoC)}{}
	\tkzMarkRightAngle[size=\kv{r},draw=\kv{col draw},\kv{width},\kv{pattern},\kv{arrow}](angolorettoPuntoA,angolorettoPuntoB,angolorettoPuntoC)
}


%%%%%%%%%%%%%%%% RETTE E SEMIRETTE

% \retta[keys]{A}{B} crea una retta da A a B
\newcommand{\retta}[3][]{
	\tikzset{keyfld/.cd,
		draw length/.initial,
		prol length/.initial = 0.8,
		col/.initial,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		pattern draw/.initial, % può essere solid, dashed, dotted, ...
		pattern prol/.initial = dashed, % può essere solid, dashed, dotted, ...
		name path/.initial, % può essere usato per dare un nome al path (per il tratto continuo)
		lbl/.initial,
		lbl name/.initial, % il nome da dare alla posizione del label
		lbl dist/.initial = 0.2, % la distanza da aggiungere al raggio
		flip lbl/.initial = false, % dice se vogliamo ribaltare la posizione del label
		lbl size/.initial,
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\copykeyvalueifempty{pattern draw}{pattern}
	\ifkeyempty{draw length}{
		\ifkeyempty{name path}
			{\draw[\kv{col},\kv{width},\kv{pattern draw}](#2)--(#3);}
			{\draw[\kv{col},\kv{width},\kv{pattern draw},name path=\kv{name path}](#2)--(#3);}
		\allont[\kv{prol length}]{rettaProlA}{#2}{#3};
		\allont[\kv{prol length}]{rettaProlB}{#3}{#2};
		\draw[\kv{col},\kv{width},\kv{pattern prol}] (#2)--(rettaProlA) (#3)--(rettaProlB);
	}{
		\allont[\kv{draw length}]{rettaDrawA}{#2}{#3};
		\allont[\kv{draw length}]{rettaDrawB}{#3}{#2};
		\ifkeyempty{name path}
			{\draw[\kv{col},\kv{width},\kv{pattern draw}](rettaDrawA)--(#2)--(#3)--(rettaDrawB);}
			{\draw[\kv{col},\kv{width},\kv{pattern draw},name path=\kv{name path}](rettaDrawA)--(#2)--(#3)--(rettaDrawB);}
		\allont[\kv{prol length}]{rettaProlA}{rettaDrawA}{#3};
		\allont[\kv{prol length}]{rettaProlB}{rettaDrawB}{#2};
		\draw[\kv{col},\kv{width},\kv{pattern prol}] (rettaDrawA)--(rettaProlA) (rettaDrawB)--(rettaProlB);
	}
	\ifkeyempty{lbl}{}{\setkeyvalueifempty{lbl name}{rettaLblName};}
	\ifkeyempty{lbl name}{}{
		\verso[0.2]{rettaFulcro}{rettaProlB}{#2};
		\ifkeyequal{flip lbl}{false}{\def\semirettaLblAng{-90}}{\def\semirettaLblAng{+90}}
		\ruotapuntoN[\kv{lbl dist}]{\kv{lbl name}}{rettaProlB}{rettaFulcro}{\semirettaLblAng};
		\stylelbl[#1]{\kv{lbl name}};
	}
}

% \semiretta[keys]{A}{B} crea una semiretta da A a B
\newcommand{\semiretta}[3][]{
	\tikzset{keyfld/.cd,
		draw length/.initial,
		prol length/.initial = 0.8,
		col/.initial,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		pattern draw/.initial, % può essere solid, dashed, dotted, ...
		pattern prol/.initial = dashed, % può essere solid, dashed, dotted, ...
		name path/.initial, % può essere usato per dare un nome al path (per il tratto continuo)
		lbl/.initial,
		lbl name/.initial, % il nome da dare alla posizione del label
		lbl dist/.initial = 0.2, % la distanza da aggiungere al raggio
		flip lbl/.initial = false, % dice se vogliamo ribaltare la posizione del label
		lbl size/.initial,
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\copykeyvalueifempty{pattern draw}{pattern}
	\ifkeyempty{draw length}{
		\ifkeyempty{name path}
			{\draw[\kv{col},\kv{width},\kv{pattern draw}](#2)--(#3);}
			{\draw[\kv{col},\kv{width},\kv{pattern draw},name path=\kv{name path}](#2)--(#3);}
		\allont[\kv{prol length}]{semirettaProlTo}{#3}{#2};
		\draw[\kv{col},\kv{width},\kv{pattern prol}](#3)--(semirettaProlTo);
	}{
		\allont[\kv{draw length}]{semirettaDrawTo}{#3}{#2};
		\ifkeyempty{name path}
			{\draw[\kv{col},\kv{width},\kv{pattern draw}](#2)--(#3)--(semirettaDrawTo);}
			{\draw[\kv{col},\kv{width},\kv{pattern draw},name path=\kv{name path}](#2)--(#3)--(semirettaDrawTo);}
		\allont[\kv{prol length}]{semirettaProlTo}{semirettaDrawTo}{#2};
		\draw[\kv{col},\kv{width},\kv{pattern prol}](semirettaDrawTo)--(semirettaProlTo);
	}
	\ifkeyempty{lbl}{}{\setkeyvalueifempty{lbl name}{semirettaLblName};}
	\ifkeyempty{lbl name}{}{
		\verso[0.2]{semirettaFulcro}{semirettaProlTo}{#2};
		\ifkeyequal{flip lbl}{false}{\def\semirettaLblAng{-90}}{\def\semirettaLblAng{+90}}
		\ruotapuntoN[\kv{lbl dist}]{\kv{lbl name}}{semirettaProlTo}{semirettaFulcro}{\semirettaLblAng};
		\stylelbl[#1]{\kv{lbl name}};
	}
}


%%%%%%%%%%%%%%%% CIRCONFERENZE

% chiama come \circCR[keys]{C}{R} per disegnare la circonferenza di centro C e raggio R
\newcommand{\circCR}[3][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		name path/.initial, % può essere usato per dare un nome al path
		fill/.initial = false,
		col fill/.initial,
		opacity/.initial = 30, % l'opacity del fill, se non è stato specificato col fill
		lbl name/.initial, % il nome da dare all'eventuale label (se presente)
		lbl/.initial,
		lbl size/.initial,
		lbl dist/.initial = 0.3, % la distanza del label dalla circonferenza
		lbl ang/.initial = -150, % l'angolo a cui mettere il label
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\ifkeyequal{fill}{true}{\setkeyvalueifempty{col fill}{\kv{col}!\kv{opacity}};}
	\ifkeyequal{pattern}{path}{
		\ifkeyempty{name path}{
			\ifkeyempty{col fill}
			{\path (#2) circle (#3);}
			{\path[fill=\kv{col fill}] (#2) circle (#3);}
		}{
			\ifkeyempty{col fill}
			{\path[name path=\kv{name path}] (#2) circle (#3);}
			{\path[name path=\kv{name path},fill=\kv{col fill}] (#2) circle (#3);}
		}
	}{
		\ifkeyempty{name path}{
			\ifkeyempty{col fill}
			{\draw[\kv{col},\kv{width},\kv{pattern}] (#2) circle (#3);}
			{\draw[\kv{col},\kv{width},\kv{pattern},fill=\kv{col fill}] (#2) circle (#3);}
		}{
			\ifkeyempty{col fill}
			{\draw[\kv{col},\kv{width},\kv{pattern},name path=\kv{name path}] (#2) circle (#3);}
			{\draw[\kv{col},\kv{width},\kv{pattern},name path=\kv{name path},fill=\kv{col fill}] (#2) circle (#3);}
		}
	}
	\ifkeyempty{lbl}{}{\setkeyvalueifempty{lbl name}{circCPlblName};}
	\ifkeyempty{lbl name}{}{\stylelbl[#1]{$(#2)+(\kv{lbl ang}:#3+\kv{lbl dist} cm)$};}
}

% \circCP[keys]{C}{P} disegna la circonferenza di centro C e passante per P
\newcommand{\circCP}[3][]{\circCPr[#1]{#2}{#3}{\circCPmisuraraggio};}

% \circCPr[keys]{C}{P}{<- r} disegna la circonferenza di centro C e passante per P. Registra in r la misura del raggio della circonferenza (in cm)
\newcommand{\circCPr}[4][]{
	\distanza{#4}{#2}{#3};
	\circCR[#1]{#2}{#4 cm};
}

% \circPPP[keys]{A}{B}{C} disegna la circonferenza passante per i tre punti A, B e C
\newcommand{\circPPP}[4][]{\circPPPcr[#1]{#2}{#3}{#4}{circPPPcentro}{\circPPPmisuraraggio};}
% \circPPPc[keys]{A}{B}{C}{<- centro} disegna la circonferenza passante per i tre punti A, B e C
\newcommand{\circPPPc}[5][]{\circPPPcr[#1]{#2}{#3}{#4}{#5}{\circPPPmisuraraggio};}
% \circPPPr[keys]{A}{B}{C}{<- raggio} disegna la circonferenza passante per i tre punti A, B e C
\newcommand{\circPPPr}[5][]{\circPPPcr[#1]{#2}{#3}{#4}{circPPPcentro}{#5};}

% \circPPPcr[keys]{A}{B}{C}{<- centro}{<- raggio} disegna la circonferenza passante per i tre punti A, B e C e registra il centro e il raggio della circonferenza
\newcommand{\circPPPcr}[6][]{
	\circocentro{#5}{#2}{#3}{#4};
	\circCPr[#1]{#5}{#2}{#6};
}


%%%%%%%%%%%%%%%% ARCHI DI CIRCONFERENZA

% questi comandi disegnano archi in senso antiorario (rilevante per eventuali frecce)

% \arcocirc[opzioni]{O}{A}{B} disegna un arco di circonferenza di centro O che va da A alla semiretta OB
\newcommand{\arcocirc}[4][]{\tkzDrawArc[#1](#2,#3)(#4);}
% \arcocircang[opzioni]{O}{A}{ang} disegna un arco di circonferenza di centro O che parte da A e ruota di un angolo ang
\newcommand{\arcocircang}[4][]{\tkzDrawArc[#1,rotate](#2,#3)(#4);}

% \semicirc[opzioni]{A}{B} disegna una semicirconferenza di diametro AB
\newcommand{\semicirc}[3][]{
	\medio{semicircCentro}{#2}{#3};
	\arcocircang[#1]{semicircCentro}{#2}{180};
}


%%%%%%%%%%%%%%%% ALTRE CONICHE

% \ellisse[opzioni]{centro}{semiasse a}{semiasse b}
\newcommand{\ellisse}[4][]{\draw[#1](#2)ellipse(#3cm and #4cm);}

% \ellisserot[opzioni]{centro}{semiasse a}{semiasse b}{ang}
\newcommand{\ellisserot}[5][]{\draw[#1,rotate around={#5:(#2)}](#2)ellipse(#3cm and #4cm);}

% \parabolaVPP[opzioni]{V}{P1}{P2} disegna un tratto di parabola con vertice V con estremi in P1 e P2. Serve che V sia fra P1 e P2. In realtà vengono disegnati due archi di parabola. \parabolaVPPy è identico a \parabolaVPP
\newcommand{\parabolaVPP}[4][]{\parabolaVPPy[#1]{#2}{#3}{#4};}
\newcommand{\parabolaVPPy}[4][]{
	\draw[#1](#2)parabola(#3);
	\draw[#1](#2)parabola(#4);
}

% \parabolaVPPx[opzioni]{V}{P1}{P2} è analogo a \parabolaVPPy per parabole con l'asse di simmetria parallelo all'asse x
\newcommand{\parabolaVPPx}[4][]{
	\coordinate(parabolaVPPxPuno)at(#3);
	\coordinate(parabolaVPPxPdue)at(#4);
	\begin{rotazione}[#2]{-90}
		\parabolaVPPy[#1]{#2}{parabolaVPPxPuno}{parabolaVPPxPdue}{-90};
	\end{rotazione}
}

% \parabolaeq[opzioni]{from:to}{a}{b}{c} (e \parabolaeqy, che è identico) disegna un ramo di parabola di equazione y=ax^2+bx+c. La funzione \parabolaeqx[opzioni]{from:to}{a}{b}{c} è analoga per disegnare il ramo di parabola x=ay^2+by+c (questa volta il range è inteso su y)
\newcommand{\parabolaeq}[5][]{\parabolaeqy[#1]{#2}{#3}{#4}{#5};}
\newcommand{\parabolaeqy}[5][]{\plot[#1]{#2}{\x}{#3*\x^2+#4*\x+#5};}
\newcommand{\parabolaeqx}[5][]{\plot[#1]{#2}{#3*\x^2+#4*\x+#5}{\x};}

% \ellisseeq[opzioni]{a}{b}{c}{d}{e} disegna un'ellisse di equazione ax^2+by^2+cx+dy+e=0
\newcommand{\ellisseeq}[6][]{
	\tikzdef\ellisseeqzerodeg{0.25*#4*#4/#2+0.25*#5*#5/#3-#6};
	\tikzdef\ellisseeqsemiassea{sqrt(\ellisseeqzerodeg/#2)};
	\tikzdef\ellisseeqsemiasseb{sqrt(\ellisseeqzerodeg/#3)};
	\ellisse[#1]{-0.5*#4/#2,-0.5*#5/#3}{\ellisseeqsemiassea}{\ellisseeqsemiasseb};
}

% \propinv[opzioni]{fromx:tox}{fromy:toy}{k} disegna una funzione del tipo x*y=k tenendo solo i punti (x,y) per cui x e y rientrano (entrambi) nei range specificati
\newcommand{\propinv}[4][]{
	\extractcoordpair[:]{\propinvfromx}{\propinvtox}{#2};
	\extractcoordpairbis[:]{\propinvfromy}{\propinvtoy}{#3};
	\tikzdef\propinvfromyx{abs(#4)/\propinvfromy};
	\tikzdef\propinvtoyx{abs(#4)/\propinvtoy};
	\plot[#1]{\propinvfromx:\propinvfromyx}{\x}{#4/\x};
	\plot[#1]{\propinvtoyx:\propinvtox}{\x}{#4/\x};
}

% \propinvshift[opzioni]{fromx:tox}{fromy:toy}{k}{shift} è analogo a \propinv ma shiftato di shift
\newcommand{\propinvshift}[5][]{\propinv[#1,shift={(#5)}]{#2}{#3}{#4};}


%%%%%%%%%%%%%%%% PLOT GENERICI

% chiama come \plot[opzioni]{from:to}{x}{y}. È parametrizzato come \x
\newcommand{\plot}[4][]{\draw[smooth,samples=100,domain=#2,#1] plot ({#3},{#4});}

% chiama come \plotcos[opzioni]{from:to}{ampiezza} o come \plotsin[opzioni]{from:to}{ampiezza}
\newcommand{\plotcos}[3][]{\plot[#1]{#2}{\x}{#3*cos(\x*180/pi)};}
\newcommand{\plotsin}[3][]{\plot[#1]{#2}{\x}{#3*sin(\x*180/pi)};}
% chiama come \plotcos[opzioni]{from:to}{ampiezza}{shift} o come \plotsin[opzioni]{from:to}{ampiezza}{shift}
\newcommand{\plotcosshift}[4][]{\plotcos[#1,shift={(#4)}]{#2}{#3};}
\newcommand{\plotsinshift}[4][]{\plotsin[#1,shift={(#4)}]{#2}{#3};}


%%%%%%%%%%%%%%%% ESTRATTORE DI COORDINATE

% \extractcoordpair[separatore]{<- \x}{<-  \y}{P} estrae le due coordinate di P e le scrive in \x e in \y. Se P è dato in coordinate polari o rappresenta un range allora il separatore da usare è : (anziché ,)
\newcommand{\extractcoordpair}[4][,]{
	\def\extractcoordpairseparator{#1}
	\def\extractcoordpairx{}
	\def\extractcoordpairy{}
	\extractcoordpairIterFist#4\extractcoordpairseparator
	\def#2{\extractcoordpairx}
	\def#3{\extractcoordpairy}
}
\newcommand{\extractcoordpairIterFist}[1]{
	\if\extractcoordpairseparator#1 
		\expandafter\extractcoordpairIterSecond
	\else 
		\estendistr\extractcoordpairx{#1}
		\expandafter\extractcoordpairIterFist
	\fi
}
\newcommand{\extractcoordpairIterSecond}[1]{
	\if\extractcoordpairseparator#1 \else
		\estendistr\extractcoordpairy{#1}
		\expandafter\extractcoordpairIterSecond
	\fi
}

% \extractcoordpairbis è identico a \extractcoordpair (non si può usare due volte \extractcoordpair, se no la seconda chiamata sovrascrive la prima)
%TODO cercare una soluzione un po' più elegante
\newcommand{\extractcoordpairbis}[4][,]{
	\def\extractcoordpairseparator{#1}
	\def\extractcoordpairxbis{}
	\def\extractcoordpairybis{}
	\extractcoordpairIterFistbis#4\extractcoordpairseparator
	\def#2{\extractcoordpairxbis}
	\def#3{\extractcoordpairybis}
}
\newcommand{\extractcoordpairIterFistbis}[1]{
	\if\extractcoordpairseparator#1 
		\expandafter\extractcoordpairIterSecondbis
	\else 
		\estendistr\extractcoordpairxbis{#1}
		\expandafter\extractcoordpairIterFistbis
	\fi
}
\newcommand{\extractcoordpairIterSecondbis}[1]{
	\if\extractcoordpairseparator#1 \else
		\estendistr\extractcoordpairybis{#1}
		\expandafter\extractcoordpairIterSecondbis
	\fi
}


%%%%%%%%%%%%%%%% UTILS

% \estendistr#1{#2} aggiunge #2 alla fine della stringa #1
\def\estendistr#1#2{\expandafter\def\expandafter#1\expandafter{#1#2}}

% \poligono[opzioni]{A,B,C,...} disegna un poligono
\newcommand{\poligono}[2][]{
	\def\poligonoInputBuilder{(} % la stringa (A)--(B)--(C)--(A) Viene costruita progressivamente
	\def\poligonoFirstPointBuilder{} % la stringa A
	\newcounter{poligonoNumPointsBuilder}
	\setcounter{poligonoNumPointsBuilder}{1}
	\poligonoIter#2;
	\draw[#1]\poligonoInputBuilder;
}
% necessario per la funzione \poligono
\newcommand{\poligonoIter}[1]{
	\ifx;#1\estendistr\poligonoInputBuilder{)--(\poligonoFirstPointBuilder)}\else
		\ifx,#1\estendistr\poligonoInputBuilder{)--(}\stepcounter{poligonoNumPointsBuilder}\else
			\estendistr\poligonoInputBuilder{#1}
			\ifnum\thepoligonoNumPointsBuilder=1
				\estendistr\poligonoFirstPointBuilder{#1}
			\fi
		\fi
		\expandafter\poligonoIter
	\fi
}

% \poligonale[opzioni]{A,B,C,...} disegna una poligonale (una linea spezzata)
\newcommand{\poligonale}[2][]{
	\def\poligonaleInputBuilder{(} % la stringa (A)--(B)--(C) Viene costruita progressivamente
	\poligonaleIter#2;
	\draw[#1]\poligonaleInputBuilder;
}
% necessario per la funzione \poligonale
\newcommand{\poligonaleIter}[1]{
	\ifx;#1\estendistr\poligonaleInputBuilder{)}\else
		\ifx,#1\estendistr\poligonaleInputBuilder{)--(}\else
			\estendistr\poligonaleInputBuilder{#1}
		\fi
		\expandafter\poligonaleIter
	\fi
}

% \carrucola[keys]{centro}{raggio esterno} disegna una carrucola
\newcommand{\carrucola}[3][]{
	\tikzset{keyfld/.cd,
		col1/.initial = gray!70, % il colore della parte più esterna
		col2/.initial = gray, % il colore della parte intermedia
		col3/.initial = black, % il colore della parte interna
		r2/.initial = 2/3, % che percentuale di carrucola (come raggio) viene coperta dai due cerchi centrali
		r3/.initial = 0.1, % che percentuale di carrucola (come raggio) viene coperta dal cerchio centrale
	} \setkeyfld{#1};
	\draw[\kv{col3},fill=\kv{col1}] (#2) circle (#3);
	\draw[\kv{col2},fill=\kv{col2}] (#2) circle (#3*\kv{r2});
	\draw[\kv{col3},fill=\kv{col3}] (#2) circle (#3*\kv{r3});
}

% \cassa[keys]{punto iniziale}{lunghezza x}{lunghezza y}
\newcommand{\cassa}[4][]{
	\tikzset{keyfld/.cd,
		ang/.initial = 0, % l'angolo di inclinazione
		col/.initial = black,
		col draw/.initial,
		col fill/.initial,
		opacity/.initial = 20,
		fill/.initial = true,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		centro/.initial, % dove registrare il nome del centro della cassa
		lbl/.initial,
		lbl style/.initial = bf, % se specificato usiamo questo stile. Le opzioni sono rm, bf, cal
		lbl size/.initial,
		lbl col/.initial,
		col lbl/.initial,
	} \setkeyfld{#1};
	\setkeyvaluesifempty
		{col draw}{\kv{col}}
		{col fill}{\kv{col}!\kv{opacity}}
	\ifkeyequal{fill}{true}{\fill[\kv{col fill}] (#2)--++(\kv{ang}:#3)--++(\kv{ang}+90:#4)--++(\kv{ang}+180:#3)--++(\kv{ang}+270:#4);}{}
	\draw[\kv{col draw},\kv{width},\kv{pattern}] (#2)--++(\kv{ang}:#3)--++(\kv{ang}+90:#4)--++(\kv{ang}+180:#3)--++(\kv{ang}+270:#4);
	\ifkeyempty{lbl}{}{\setkeyvalueifempty{centro}{cassacentro}}
	\ifkeyempty{centro}{}{\stylelbl[#1]{$(#2)+(\ang:0.5*#3)+(\ang+90:0.5*#4)$};}
}