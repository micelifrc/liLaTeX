% Questo è il pacchetto liLaTeX per tikz

\usepackage{tkz-euclide} % per alcune funzioni grafiche (come \intrette)
\usepackage{pgfplots} % pacchetto per plot
\pgfplotsset{compat=1.17} % necessario per compatibilità con versioni precedenti

%%%%%%%%%%%%%%%% AMBIENTE immagine

% le immagini vengono generalmente create fra \begin{immagine}[opzioni] e \end{immagine}
\newenvironment{immagine}[1][]
	{\ifdefstring{\TipoDoc}{immagine}{}{\begin{figure}[!ht]\centering}\begin{tikzpicture}[#1]}
	{\end{tikzpicture}\ifdefstring{\TipoDoc}{immagine}{}{\end{figure}}}

% analogo ad immagine, ma permette di aggiungere una caption
\newenvironment{immaginecap}[2][]
	{\def\immaginecapCaption{#2}\begin{figure}[!ht]\centering\begin{tikzpicture}[#1]}
	{\end{tikzpicture}\caption{\immaginecapCaption}\end{figure}}
\newenvironment{immaginecap*}[2][]
	{\def\immaginecapCaption{#2}\begin{figure}[!ht]\centering\begin{tikzpicture}[#1]}
	{\end{tikzpicture}\caption*{\immaginecapCaption}\end{figure}}


%%%%%%%%%%%%%%%% KEY MANAGER

% da chiamare all'inizio di qualunque comando con dei parametri opzionali come \setkeyfld{parametri opzionali}. Dovrebbe essere sempre la seconda riga di qualunque newcommand con parametri opzionali
\newcommand\setkeyfld[1]{
	% passiamo alla key directory keyfld, e ridefiniamo come #1 tutti le keys specificate in #1
	\tikzset{keyfld/.cd,#1}%
	% definiamo un soprannome \kv per il path alle keys. In questo modo, per riferirci al VALORE di una chiave chiamata K dovremo scrivere \kv{K}, anziché la più lunga /tikz/keyfld/K. Quindi K indica la chiave, mentre \kv{K} indica il suo valore
	\def\kv##1{\pgfkeysvalueof{/tikz/keyfld/##1}}
}

% ifkeyequal{keyname}{value to compare}{do if equal}{do if different}
\newcommand\ifkeyequal[4]{
	\edef\ifkeyequalkey{\kv{#1}} 
	\edef\ifkeyequalcomp{#2}
	\ifdefequal{\ifkeyequalkey}{\ifkeyequalcomp}{#3}{#4}
}
% \ifkeyempty{keyname}{do if empty}{do if non-empty}
\newcommand\ifkeyempty[3]{\ifkeyequal{#1}{\pgfkeysnovalue}{#2}{#3}}

% aggiorna il valore della key #1 al valore #2. Chiama ad esempio come \setkeyvalue{color}{blue} o come \setkeyvalue{h}{\kv{b}}
\newcommand\setkeyvalue[2]{\tikzset{keyfld/.cd,#1=#2}}
% aggiorna il valore della key #1 al valore #2 solo se #1 è empty
\newcommand\setkeyvalueifempty[2]{\ifkeyempty{#1}{\setkeyvalue{#1}{#2}}{}}


%%%%%%%%%%%%%%%% FUNZIONI

% converte da pt a cm. Chiama come \convertto{cm}{misura pt}
\makeatletter
\def\convertto#1#2{\strip@pt\dimexpr #2*65536/\number\dimexpr 1#1}
\makeatother

% restituisce in output il nome del comando in input
\newcommand{\commandname}[1]{\expandafter{\string#1}}

% restituisce il nome del comando #1 senzo lo slash
\newcommand{\commandstring}[1]{\removeslash{#1}}

% rimuove lo \ dall'input
\newcommand{\removeslash}[1]{{\catcode92=9 \endlinechar-1 \scantokens{#1}}}

% calcola la distanza (in cm) fra #1 e #2
\newcommand{\getdistanza}[2]{\tkzCalcLength(#1,#2) \tkzGetLength{getdistanzaAB} \convertto{cm}{\getdistanzaAB pt}}

% registra la distanza fra #2 e #3 in #1
\newcommand{\distanza}[3]{\tkzCalcLength(#2,#3) \tkzGetLength{distanzaTemp} \def#1{\convertto{cm}{\distanzaTemp pt}};}

% angolopolare{<- \a}{P}{O} registra in \a la coordinata angolare di P in un sistema di rif. centrato in O
\newcommand{\angolopolare}[3]{
	\coordinate(angolopolareterzopunto)at($(#3)+(1,0)$);
	\tkzFindAngle(angolopolareterzopunto,#3,#2) \tkzGetAngle{angolopolareoutput} \def#1{\angolopolareoutput};
}

% \addlabel[opzioni]{P}{L}{ang} aggiunge un label L al punto P
\newcommand{\addlabel}[4][]{\tkzLabelPoint(#2){#3}}


%%%%%%%%%%%%%%%% PUNTO

% chiama come \punto[keys]{coordinate}
\newcommand{\punto}[2][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		size/.initial = 1.5,
		shape/.initial = circle, % circle, rettangle, diamond o lo si può lasciare vuoto
		name/.initial = puntoNome,
		lbl/.initial,
		lbl ang/.initial = -90,
		lbl dist/.initial = 0.3,
		lbl size/.initial,
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\setkeyvalueifempty{col lbl}{\kv{col}};
	\setkeyvalueifempty{lbl col}{\kv{col lbl}};
	\coordinate[\kv{shape},inner sep=\kv{size},fill=\kv{col}] (\kv{name}) at (#2);
	\ifkeyempty{lbl}{}{\node[\kv{lbl col}](puntoLblName) at($(#2)+(\kv{lbl ang}:\kv{lbl dist})$) {\kv{lbl size}\kv{lbl}}};
}

% chiama come \pnt[col]{nome}{coordinate}
\newcommand{\pnt}[3][]{\punto[name=#2,col=#1]{#3};}
% chiama come \pntlbl[col]{nome}{lbl}{lbl ang}{coordinate}
\newcommand{\pntlbl}[5][]{\punto[name=#2,lbl=#3,lbl ang=#4,col=#1]{#5};}
% chiama come \pntl[col]{name}{lbl ang}{coordinate}
\newcommand{\pntl}[4][]{\pntlbl[#1]{#2}{$#2$}{#3}{#4};}
% chiama come \pntlp[col]{name}{lbl ang}{coordinate}
\newcommand{\pntlp}[4][]{\pntlbl[#1]{#2p}{$#2'$}{#3}{#4};}
% chiama come \pntls[col]{name}{lbl ang}{coordinate}
\newcommand{\pntls}[4][]{\pntlbl[#1]{#2s}{$#2''$}{#3}{#4};}


%%%%%%%%%%%%%%%% CALCOLO DI COORDINATE

% \verso[L]{<- P}{A}{B} crea un punto P ottenuto traslando A verso B per una lunghezza complessiva L
\newcommand{\verso}[4][1]{\coordinate (#2) at ($(#3)!#1cm!(#4)$);}
% \allont[L]{<- P}{A}{B} analogo di \verso ma allontanandosi da B
\newcommand{\allont}[4][1]{\verso[-#1]{#2}{#3}{#4};}

% \parallelo[L]{<- P}{S}{A}{B} crea un punto P, ottenuto traslando S per una lunghezza L nel verso nel vettore AB
\newcommand{\parallelo}[5][1]{\coordinate (#2) at ($(#3)-(#4)+(#4)!#1cm!(#5)$);}

% \perpendicolare[L]{<- P}{S}{A}{B} crea un punto P, ottenuto traslando S per una lunghezza L nel verso perpendicolare a AB (si suppone SAB in senso antiorario)
\newcommand{\perpendicolare}[5][1]{\coordinate (#2) at ($(#3)-(#4)+(#4)!#1cm!-90:(#5)$);}

% \medio[k]{<- M}{A}{B} definisce M come il punto k*A+(1-k)*B. Nel caso speciale di k=0.5, M è il punto medio del segmento AB
\newcommand{\medio}[4][0.5]{\coordinate(#2)at($(#3)-#1*(#3)+#1*(#4)$);}

% \opposto{<- P'}{P}{O} crea l'opposto P' di P rispetto al centro di simmetria O
\newcommand{\opposto}[3]{\coordinate(#1)at($2*(#3)-(#2)$);}

% \simmetrico{<- P'}{P}{A}{B} crea il punto P', simmetrico di P rispetto alla retta di simmetria AB
\newcommand{\simmetrico}[4]{
	\proj{simmetricoPuntoDiProiezione}{#2}{#3}{#4};
	\opposto{#1}{#2}{simmetricoPuntoDiProiezione};
}

% \proj{<- H}{P}{A}{B} genera H come la proiezione ortogonale di P sulla retta AB
\newcommand{\proj}[4]{\tkzDefPointBy[projection=onto #3--#4](#2) \tkzGetPoint{#1};}

% \sumvett{<- C}{A}{B}{D} definisce il punto C in modo che il vettore AC sia uguale alla somma vettoriale AB+AD. Così facendo ABCD forma un parallelogramma
\newcommand{\sumvett}[4]{\coordinate(#1)at($(#3)-(#2)+(#4)$);}

% \ruotapunto{<- R}{P}{O}{a} definisce il punto R ottenuto ruotando P in senso antiorario di un angolo a (con centro di rotazione in O)
\newcommand{\ruotapunto}[4]{\tkzDefPointBy[rotation= center #3 angle #4](#2) \tkzGetPoint{#1};}

% \ruotapuntoN[L]{<- R}{P}{O}{a} dopo aver ruotato il punto, lo normalizza per farlo diventare di luunghezza L
\newcommand{\ruotapuntoN}[5][1]{
	\ruotapunto{ruotapuntoNnonnormalizzato}{#3}{#4}{#5};
	\verso[#1]{#2}{#4}{ruotapuntoNnonnormalizzato};
}

% \triangoloequilatero{<- C}{A}{B} prende in input due punti A e B, e definisce un terzo punto C in modo che ABC sia un triangolo equilatero (coi vertici scritti in senso antiorario)
\newcommand{\triangoloequilatero}[3]{\tkzDefTriangle[equilateral](#2,#3) \tkzGetPoint{#1}}


%%%%%%%%%%%%%%%% INTERSEZIONI

% \intpahts{<- I}{path1}{path2} trova il punto di intersezione fra due paths e lo chiama I
\newcommand{\intpaths}[3]{\path [name intersections={of=#2 and #3,by=#1}];}

% \intrette{<- I}{A}{B}{C}{D} trova il punto di intersezione I fra le rette AB e CD
\newcommand{\intrette}[5]{\tkzInterLL(#2,#3)(#4,#5) \tkzGetPoint{#1};}


%%%%%%%%%%%%%%%% SISTEMI DI RIFERIMENTO E GRIGLIE

% \sistrif[keys]{centro}{angolo} crea il sistema di riferimento
\newcommand{\sistrif}[3][]{
	\tikzset{keyfld/.cd,
		col/.initial = teal,
		arrow/.initial = ->,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		front/.initial = 2, % la lunghezza con cui andiamo avanti
		back/.initial = 0.3, % la lunghezza per cui andiamo indietro
		front x/.initial,
		back x/.initial,
		front y/.initial,
		back y/.initial,
		flip/.initial = false, % rendi true se vuoi capovolgere il verso dell'asse y
		label/.initial = true, % rengi false se non vuoi il label
		lbl dist/.initial = 0.3,
		lbl x/.initial = $x$,
		lbl y/.initial = $y$,
		col lbl/.initial,
	} \setkeyfld{#1};
	\setkeyvalueifempty{front x}{\kv{front}};
	\setkeyvalueifempty{front y}{\kv{front}};
	\setkeyvalueifempty{back x}{\kv{back}};
	\setkeyvalueifempty{back y}{\kv{back}};
	\setkeyvalueifempty{col lbl}{\kv{col}};
	\ifkeyequal{flip}{false}{\def\sistrifflipper{+1}}{\def\sistrifflipper{-1}}
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] ($(#2)+(#3:-\kv{back x})$) -- ($(#2)+(#3:\kv{front x})$)node(sistrifLblXpunta){};
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] ($(#2)+(\sistrifflipper*90+#3:-\kv{back y})$) -- ($(#2)+(\sistrifflipper*90+#3:\kv{front y})$)node(sistrifLblYpunta){};
	\ifkeyequal{label}{true}{
		\node[\kv{col lbl}](sistrifLblXlabel)at($(sistrifLblXpunta)+(#3-90*\sistrifflipper:\kv{lbl dist})$){\kv{lbl x}};
		\node[\kv{col lbl}](sistrifLblYlabel)at($(sistrifLblYpunta)+(#3+180:\kv{lbl dist})$){\kv{lbl y}};
	}{}
}

% \assex[keys]{x-left}{x-right} crea l'asse x
\newcommand{\assex}[3][]{
	\tikzset{keyfld/.cd,
		y/.initial = 0, % la y del centro
		ang shift/.initial = 0,
		col/.initial,
		arrow/.initial = ->,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		lbl/.initial = $x$,
		lbl name/.initial = assexlbl, % il nome da dare al label
		lbl dist/.initial = 0.3,
		col lbl/.initial,
		flip lbl/.initial = false, % rendi true se vuoi ribaltare il label
	} \setkeyfld{#1};
	\setkeyvalueifempty{col lbl}{\kv{col}};
	\ifkeyequal{flip lbl}{true}{\def\assexflipper{180}}{\def\assexflipper{0}};
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] ($(0,\kv{y})+(\kv{ang shift}:#2)$) -- ($(0,\kv{y})+(\kv{ang shift}:#3)$)node(assexpunta){};
	\node[\kv{col lbl}](\kv{lbl name}) at ($(assexpunta)+(\kv{ang shift}-90+\assexflipper:\kv{lbl dist})$){\kv{lbl}};
}

% \assey[keys]{y-bottom}{y-top} crea l'assey
\newcommand{\assey}[3][]{
	\tikzset{keyfld/.cd,
		x/.initial = 0, % la x del centro
		ang shift/.initial = 0,
		col/.initial,
		arrow/.initial = ->,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		lbl/.initial = $y$,
		lbl name/.initial = asseylbl, % il nome da dare al label
		lbl dist/.initial = 0.3,
		col lbl/.initial,
		flip lbl/.initial = false, % rendi true se vuoi ribaltare il label
	} \setkeyfld{#1};
	\setkeyvalueifempty{col lbl}{\kv{col}};
	\ifkeyequal{flip lbl}{true}{\def\asseyflipper{180}}{\def\asseyflipper{0}};
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] ($(\kv{x},0)+(\kv{ang shift}+90:#2)$) -- ($(\kv{x},0)+(\kv{ang shift}+90:#3)$)node(asseypunta){};
	\node[\kv{col lbl}](\kv{lbl name}) at ($(asseypunta)+(\kv{ang shift}+180+\asseyflipper:\kv{lbl dist})$){\kv{lbl}};
}

% \assixy[keys]{x-left}{x-right}{y-left}{y-right} disegna gli assi cartesiani
\newcommand{\assixy}[5][]{
	\tikzset{keyfld/.cd,
		x/.initial = 0, % la x del centro
		y/.initial = 0, % la y del centro
		col/.initial,
		arrow/.initial = ->,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		lbl x/.initial = $x$,
		lbl y/.initial = $y$,
		lbl x name/.initial = assixylblx, % il nome da dare al label per y
		lbl y name/.initial = assixylbly, % il nome da dare al label per y
		lbl dist/.initial = 0.3,
		col lbl/.initial,
	} \setkeyfld{#1};
	\assixyO[#1]{\kv{x},\kv{y}}{#2}{#3}{#4}{#5};
}

% \assixyO[keys]{centro}{x-left}{x-right}{y-left}{y-right} disegna gli assi cartesiani
\newcommand{\assixyO}[6][]{
	\tikzset{keyfld/.cd,
		col/.initial,
		arrow/.initial = ->,
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		lbl x/.initial = $x$,
		lbl y/.initial = $y$,
		lbl x name/.initial = assixylblx, % il nome da dare al label per y
		lbl y name/.initial = assixylbly, % il nome da dare al label per y
		lbl dist/.initial = 0.3,
		col lbl/.initial,
	} \setkeyfld{#1};
	\setkeyvalueifempty{col lbl}{\kv{col}};
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] (#3,0|-#2)--(#4,0|-#2)node(assixypuntax){};
	\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}] (0,#5-|#2)--(0,#6-|#2)node(assixypuntay){};
	\node[\kv{col lbl}](\kv{lbl x name}) at ($(assixypuntax)+(-90:\kv{lbl dist})$){\kv{lbl x}};
	\node[\kv{col lbl}](\kv{lbl y name}) at ($(assixypuntay)+(180:\kv{lbl dist})$){\kv{lbl y}};
}

% \assexbar[keys]{\x}{lbl}
\newcommand{\assexbar}[3][]{
	\tikzset{keyfld/.cd,
		y/.initial = 0, % la y dell'asse cartesiano
		col/.initial,
		arrow/.initial,
		width/.initial = very thin, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		size/.initial = .2, % la dimensione della barretta verticale
		col lbl/.initial,
		flip/.initial = false, % se posto a true il label viene messo verso l'alto anziché verso il basso
	} \setkeyfld{#1};
	\ifnum\value{TipoDocVerificaCounter}=0 \setkeyvalueifempty{col}{gray} \fi % se non è una verifica la barra viene colorata di grigio
	\setkeyvalueifempty{col lbl}{\kv{col}};
	\ifkeyequal{flip}{false}
	{\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}](#2,\kv{y}+0.5*\kv{size})--++(0,-\kv{size})node[anchor=north,\kv{col lbl}]{#3};}
	{\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}](#2,\kv{y}-0.5*\kv{size})--++(0,+\kv{size})node[anchor=south,\kv{col lbl}]{#3};}
}

% \asseybar[keys]{\y}{lbl}
\newcommand{\asseybar}[3][]{
	\tikzset{keyfld/.cd,
		x/.initial = 0, % la x dell'asse cartesiano
		col/.initial,
		arrow/.initial,
		width/.initial = very thin, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		size/.initial = .2, % la dimensione della barretta verticale
		col lbl/.initial,
		flip/.initial = false, % se posto a true il label viene messo verso l'alto anziché verso il basso
	} \setkeyfld{#1};
	\ifnum\value{TipoDocVerificaCounter}=0 \setkeyvalueifempty{col}{gray} \fi % se non è una verifica la barra viene colorata di grigio
	\setkeyvalueifempty{col lbl}{\kv{col}};
	\ifkeyequal{flip}{false}
	{\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}](\kv{x}+0.5*\kv{size},#2)--++(-\kv{size},0)node[anchor=east,\kv{col lbl}]{#3};}
	{\draw[\kv{col},\kv{arrow},\kv{width},\kv{pattern}](\kv{x}-0.5*\kv{size},#2)--++(+\kv{size},0)node[anchor=west,\kv{col lbl}]{#3};}
}


%%%%%%%%%%%%%%%% TRIANGOLI

% \piedemed[k]{<- P}{A}{B}{C} trova il piede P della mediana BP (k è un parametro fra 0 e 1 che "sposta" P lungo il lato AC)
\newcommand{\piedemed}[5][0.5]{\medio[#1]{#2}{#3}{#5};}

% \piedealt{<- P}{A}{B}{C} trova P (il piede dell'altezza BP)
\newcommand{\piedealt}[4]{\proj{#1}{#3}{#2}{#4};}

% \piedebis[temp]{<- P}{A}{B}{C} trova P (il piede della bisettrice dell'angolo ABC)
\newcommand{\piedebis}[5][piedebisTemp]{
	\tkzDefLine[bisector](#3,#4,#5) \tkzGetPoint{#1}
	\intrette{#2}{#4}{#1}{#3}{#5};
}

% \centrotriangolo[type]{<- P}{A}{B}{C} trova il centro del triangolo (funzione usata per definire i successivi 5 comandi)
\newcommand{\centrotriangolo}[5][centroid]{\tkzDefTriangleCenter[#1](#3,#4,#5) \tkzGetPoint{#2};}
% \baricentro{<- P}{A}{B}{C} trova il baricentro P di un triangolo ABC
\newcommand{\baricentro}[4]{\centrotriangolo[centroid]{#1}{#2}{#3}{#4}}
% \ortocentro{<- P}{A}{B}{C} trova il baricentro P di un triangolo ABC
\newcommand{\ortocentro}[4]{\centrotriangolo[ortho]{#1}{#2}{#3}{#4}}
% \circocentro{<- P}{A}{B}{C} trova il baricentro P di un triangolo ABC
\newcommand{\circocentro}[4]{\centrotriangolo[circum]{#1}{#2}{#3}{#4}}
% \incentro{<- P}{A}{B}{C} trova il baricentro P di un triangolo ABC
\newcommand{\incentro}[4]{\centrotriangolo[in]{#1}{#2}{#3}{#4}}
% \exocentro{<- P}{A}{B}{C} trova il baricentro P di un triangolo ABC (opposto a B)
\newcommand{\excentro}[4]{\centrotriangolo[ex]{#1}{#2}{#3}{#4}}


%%%%%%%%%%%%%%%% MARKS accettano le opzioni s,z,x,o,oo,|,||,|||

% chiama come \segmento[keys]{A}{B} per disegnare il segmento
\newcommand{\segmento}[3][]{
	\tikzset{keyfld/.cd,
		col/.initial = black,
		col draw/.initial, % il colore con cui si disegna il lato
		mark/.initial = none, % il segno da mettere al segmento
		mark size/.initial = 0.2, % la dimensione del segno
		col mark/.initial = black, % il colore del segno
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		arrow/.initial, % può essere ->, <-, <-> (o lasciata vuota)
		name path/.initial, % può essere usato per dare un nome al path
		lbl/.initial,
		lbl name/.initial, % il nome da dare alla posizione del label
		lbl dist/.initial = 0.2, % la distanza da aggiungere al raggio
		lbl size/.initial,
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\setkeyvalueifempty{col draw}{\kv{col}};
	\setkeyvalueifempty{col lbl}{\kv{col}};
	\setkeyvalueifempty{lbl col}{\kv{col lbl}};
	\ifkeyempty{lbl}{}{\setkeyvalueifempty{lbl name}{segmentoLabelPos};}
	\draw[\kv{col draw},\kv{width},\kv{pattern},\kv{arrow}](#2)--(#3);
	\tkzMarkSegment[mark=\kv{mark},\kv{col mark},size=\kv{mark size}cm](#2,#3)
	\ifkeyempty{lbl name}{}{
		\medio{segmentoPuntoMedio}{#2}{#3};
		\ruotapuntoN[\kv{lbl dist}]{\kv{lbl name}}{#2}{segmentoPuntoMedio}{90};
	}
	\ifkeyempty{lbl}{}{\node[\kv{lbl col}](segmentoLabel)at(\kv{lbl name}){\kv{lbl size}\kv{lbl}};}
}

% chiama come \markarco[keys]{m}{O}{A}{B} per creare un mark nel punto medio dell'arco di circonferenza AB di centro O. m indica il marchio richiesto (fra s,z,x,o,oo,|,||,|||)
\newcommand{\markarco}[5][]{
	\tikzset{keyfld/.cd,
		col/.initial = black,
		size/.initial = 0.2, % la dimensione del segno
	} \setkeyfld{#1};
	\piedebis[markarcoPiedeBisettriceTemp]{markarcoPiedeBisettrice}{#4}{#3}{#5};
	\distanza{\markarcoRaggioCirconferenza}{#3}{#4};
	\verso[\markarcoRaggioCirconferenza]{markarcoPuntoMedioArco}{#3}{markarcoPiedeBisettrice};
	\ruotapuntoN{markarcoEstremoP}{#3}{markarcoPuntoMedioArco}{+90};
	\ruotapuntoN{markarcoEstremoM}{#3}{markarcoPuntoMedioArco}{-90};
	\tkzMarkSegment[mark=#2,\kv{col},size=\kv{size}cm](markarcoEstremoP,markarcoEstremoM)
}

% chiama come \angolo[keys]{A}{B}{C} per disegnare l'angolo in senso antiorario
\newcommand{\angolo}[4][]{
	\tikzset{keyfld/.cd,
		col/.initial = black,
		col draw/.initial, % il colore con cui si disegna l'angolo
		r/.initial = 0.6, % il raggio dell'angolo
		mark/.initial = none, % il segno da mettere all'angolo
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		arrow/.initial, % può essere ->, <-, <-> (o lasciata vuota)
		fill/.initial = false, % può essere true o false
		col fill/.initial, % il colore del filling
		opacity/.initial = 0.3, % un numero fra 0 e 1 ch indica l'intensità della colorazione
		lbl/.initial,
		lbl dist/.initial = 0.2, % la distanza da aggiungere al raggio
		lbl size/.initial,
		lbl col/.initial,
		col lbl/.initial, % uguale a lbl col (così li accetta entrambi)
	} \setkeyfld{#1};
	\setkeyvalueifempty{col draw}{\kv{col}};
	\setkeyvalueifempty{col lbl}{\kv{col}};
	\setkeyvalueifempty{lbl col}{\kv{col lbl}};
	\ifkeyempty{col fill}{}{\setkeyvalue{fill}{true}};
	\ifkeyequal{fill}{true}{\setkeyvalueifempty{col fill}{\kv{col}}}{};
	\coordinate(angoloPuntoA)at(#2);
	\coordinate(angoloPuntoB)at(#3);
	\coordinate(angoloPuntoC)at(#4);
	\ifkeyequal{fill}{true}{\tkzFillAngle[size=\kv{r},opacity=\kv{opacity},fill=\kv{col fill}](angoloPuntoA,angoloPuntoB,angoloPuntoC)}{}
	\tkzMarkAngle[mark=\kv{mark},size=\kv{r},draw=\kv{col draw},\kv{width},\kv{pattern},\kv{arrow}](angoloPuntoA,angoloPuntoB,angoloPuntoC)
	\ifkeyempty{lbl}{}{\tkzLabelAngle[pos=\kv{r}+\kv{lbl dist},\kv{lbl col}](angoloPuntoA,angoloPuntoB,angoloPuntoC){\kv{lbl size}\kv{lbl}}}
}

% chiama come \angoloretto[keys]{A}{B}{C} per disegnare l'angolo retto in senso antiorario
\newcommand{\angoloretto}[4][]{
	\tikzset{keyfld/.cd,
		col/.initial = black,
		col draw/.initial, % il colore con cui si disegna l'angolo
		r/.initial = 0.4, % il lato del segmento del quadratino
		width/.initial, % può essere thin, thick, ...
		pattern/.initial, % può essere solid, dashed, dotted, ...
		arrow/.initial, % può essere ->, <-, <-> (o lasciata vuota)
		fill/.initial = false, % può essere true o false
		col fill/.initial, % il colore del filling
		opacity/.initial = 0.3, % un numero fra 0 e 1 ch indica l'intensità della colorazione
	} \setkeyfld{#1};
	\setkeyvalueifempty{col draw}{\kv{col}};
	\ifkeyempty{col fill}{}{\setkeyvalue{fill}{true}};
	\ifkeyequal{fill}{true}{\setkeyvalueifempty{col fill}{\kv{col}}}{};
	\coordinate(angolorettoPuntoA)at(#2);
	\coordinate(angolorettoPuntoB)at(#3);
	\coordinate(angolorettoPuntoC)at(#4);
	\ifkeyequal{fill}{true}
	{\tkzMarkRightAngle[size=\kv{r},\kv{width},\kv{pattern},fill=\kv{col fill},opacity=\kv{opacity}](angolorettoPuntoA,angolorettoPuntoB,angolorettoPuntoC)}{}
	\tkzMarkRightAngle[size=\kv{r},draw=\kv{col draw},\kv{width},\kv{pattern},\kv{arrow}](angolorettoPuntoA,angolorettoPuntoB,angolorettoPuntoC)
}